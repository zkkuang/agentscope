# AgentScope é¡¹ç›®å®Œæ•´æ¶æ„æ·±åº¦åˆ†ææ–‡æ¡£

> æœ¬æ–‡æ¡£å¯¹ AgentScope å¤š Agent æ¡†æ¶è¿›è¡Œå…¨é¢æ·±å…¥çš„åˆ†æï¼Œæ¶µç›–é¡¹ç›®ç»“æ„ã€æ ¸å¿ƒæ¨¡å—ã€å®ç°æœºåˆ¶ã€è®¾è®¡ç†å¿µå’Œä½¿ç”¨æŒ‡å—

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0
**é¡¹ç›®ç‰ˆæœ¬**: AgentScope 1.0.4
**åˆ†ææ—¥æœŸ**: 2025-10-07
**é¡¹ç›®åœ°å€**: https://github.com/agentscope-ai/agentscope
**ä½œè€…**: AgentScope ç¤¾åŒº

---

## ğŸ“‘ ç›®å½•

- [ç¬¬ä¸€ç« : é¡¹ç›®æ¦‚è§ˆ](#ç¬¬ä¸€ç« -é¡¹ç›®æ¦‚è§ˆ)
  - [1.1 é¡¹ç›®ç®€ä»‹ä¸ç‰¹è‰²](#11-é¡¹ç›®ç®€ä»‹ä¸ç‰¹è‰²)
  - [1.2 æŠ€æœ¯æ ˆä¸ä¾èµ–](#12-æŠ€æœ¯æ ˆä¸ä¾èµ–)
  - [1.3 é¡¹ç›®ç›®å½•ç»“æ„](#13-é¡¹ç›®ç›®å½•ç»“æ„)
  - [1.4 åˆå§‹åŒ–ä¸é…ç½®](#14-åˆå§‹åŒ–ä¸é…ç½®)

- [ç¬¬äºŒç« : æ ¸å¿ƒæ¶æ„è®¾è®¡](#ç¬¬äºŒç« -æ ¸å¿ƒæ¶æ„è®¾è®¡)
  - [2.1 æ•´ä½“æ¶æ„å›¾](#21-æ•´ä½“æ¶æ„å›¾)
  - [2.2 æ ¸å¿ƒæ¦‚å¿µè¯¦è§£](#22-æ ¸å¿ƒæ¦‚å¿µè¯¦è§£)
  - [2.3 è®¾è®¡å“²å­¦](#23-è®¾è®¡å“²å­¦)
  - [2.4 å¼‚æ­¥ä¼˜å…ˆæ¶æ„](#24-å¼‚æ­¥ä¼˜å…ˆæ¶æ„)

- [ç¬¬ä¸‰ç« : Agent æ¨¡å—æ·±åº¦è§£æ](#ç¬¬ä¸‰ç« -agent-æ¨¡å—æ·±åº¦è§£æ)
  - [3.1 AgentBase åŸºç±»](#31-agentbase-åŸºç±»)
  - [3.2 é’©å­ç³»ç»Ÿè¯¦è§£](#32-é’©å­ç³»ç»Ÿè¯¦è§£)
  - [3.3 ReActAgent å®ç°](#33-reactagent-å®ç°)
  - [3.4 UserAgent å®ç°](#34-useragent-å®ç°)

- [ç¬¬å››ç« : Model æ¨¡å—è¯¦ç»†åˆ†æ](#ç¬¬å››ç« -model-æ¨¡å—è¯¦ç»†åˆ†æ)
  - [4.1 ChatModelBase åŸºç±»](#41-chatmodelbase-åŸºç±»)
  - [4.2 å“åº”å¯¹è±¡è®¾è®¡](#42-å“åº”å¯¹è±¡è®¾è®¡)
  - [4.3 å„å‚å•†æ¨¡å‹å®ç°](#43-å„å‚å•†æ¨¡å‹å®ç°)
  - [4.4 æµå¼å¤„ç†æœºåˆ¶](#44-æµå¼å¤„ç†æœºåˆ¶)

- [ç¬¬äº”ç« : Message ä¸é€šä¿¡æœºåˆ¶](#ç¬¬äº”ç« -message-ä¸é€šä¿¡æœºåˆ¶)
  - [5.1 Msg ç±»è®¾è®¡](#51-msg-ç±»è®¾è®¡)
  - [5.2 å†…å®¹å—ç³»ç»Ÿ](#52-å†…å®¹å—ç³»ç»Ÿ)
  - [5.3 å¤šæ¨¡æ€æ”¯æŒ](#53-å¤šæ¨¡æ€æ”¯æŒ)
  - [5.4 æ¶ˆæ¯åºåˆ—åŒ–](#54-æ¶ˆæ¯åºåˆ—åŒ–)

- [ç¬¬å…­ç« : Tool å·¥å…·ç³»ç»Ÿ](#ç¬¬å…­ç« -tool-å·¥å…·ç³»ç»Ÿ)
  - [6.1 Toolkit ç®¡ç†å™¨](#61-toolkit-ç®¡ç†å™¨)
  - [6.2 å·¥å…·æ³¨å†Œæœºåˆ¶](#62-å·¥å…·æ³¨å†Œæœºåˆ¶)
  - [6.3 å·¥å…·ç»„ç®¡ç†](#63-å·¥å…·ç»„ç®¡ç†)
  - [6.4 MCP é›†æˆ](#64-mcp-é›†æˆ)
  - [6.5 å†…ç½®å·¥å…·å‡½æ•°](#65-å†…ç½®å·¥å…·å‡½æ•°)

- [ç¬¬ä¸ƒç« : Memory è®°å¿†ç³»ç»Ÿ](#ç¬¬ä¸ƒç« -memory-è®°å¿†ç³»ç»Ÿ)
  - [7.1 çŸ­æœŸè®°å¿†è®¾è®¡](#71-çŸ­æœŸè®°å¿†è®¾è®¡)
  - [7.2 é•¿æœŸè®°å¿†é›†æˆ](#72-é•¿æœŸè®°å¿†é›†æˆ)
  - [7.3 è®°å¿†ç®¡ç†ç­–ç•¥](#73-è®°å¿†ç®¡ç†ç­–ç•¥)

- [ç¬¬å…«ç« : Formatter æ ¼å¼åŒ–ç³»ç»Ÿ](#ç¬¬å…«ç« -formatter-æ ¼å¼åŒ–ç³»ç»Ÿ)
  - [8.1 æ ¼å¼åŒ–å™¨åŸºç±»](#81-æ ¼å¼åŒ–å™¨åŸºç±»)
  - [8.2 å„å‚å•†æ ¼å¼åŒ–å™¨](#82-å„å‚å•†æ ¼å¼åŒ–å™¨)
  - [8.3 æˆªæ–­ç­–ç•¥](#83-æˆªæ–­ç­–ç•¥)

- [ç¬¬ä¹ç« : Pipeline å·¥ä½œæµç¼–æ’](#ç¬¬ä¹ç« -pipeline-å·¥ä½œæµç¼–æ’)
  - [9.1 MsgHub æ¶ˆæ¯ä¸­å¿ƒ](#91-msghub-æ¶ˆæ¯ä¸­å¿ƒ)
  - [9.2 Pipeline æ¨¡å¼](#92-pipeline-æ¨¡å¼)
  - [9.3 å¤æ‚å·¥ä½œæµè®¾è®¡](#93-å¤æ‚å·¥ä½œæµè®¾è®¡)

- [ç¬¬åç« : Plan è§„åˆ’ç³»ç»Ÿ](#ç¬¬åç« -plan-è§„åˆ’ç³»ç»Ÿ)
  - [10.1 PlanNotebook è®¾è®¡](#101-plannotebook-è®¾è®¡)
  - [10.2 ä»»åŠ¡åˆ†è§£æœºåˆ¶](#102-ä»»åŠ¡åˆ†è§£æœºåˆ¶)
  - [10.3 è®¡åˆ’æ‰§è¡Œè¿½è¸ª](#103-è®¡åˆ’æ‰§è¡Œè¿½è¸ª)

- [ç¬¬åä¸€ç« : RAG æ£€ç´¢å¢å¼º](#ç¬¬åä¸€ç« -rag-æ£€ç´¢å¢å¼º)
  - [11.1 KnowledgeBase è®¾è®¡](#111-knowledgebase-è®¾è®¡)
  - [11.2 æ–‡æ¡£å¤„ç†](#112-æ–‡æ¡£å¤„ç†)
  - [11.3 å‘é‡å­˜å‚¨](#113-å‘é‡å­˜å‚¨)

- [ç¬¬åäºŒç« : MCP åè®®é›†æˆ](#ç¬¬åäºŒç« -mcp-åè®®é›†æˆ)
  - [12.1 MCP å®¢æˆ·ç«¯æ¶æ„](#121-mcp-å®¢æˆ·ç«¯æ¶æ„)
  - [12.2 HTTP å®¢æˆ·ç«¯](#122-http-å®¢æˆ·ç«¯)
  - [12.3 StdIO å®¢æˆ·ç«¯](#123-stdio-å®¢æˆ·ç«¯)

- [ç¬¬åä¸‰ç« : è¾…åŠ©æ¨¡å—](#ç¬¬åä¸‰ç« -è¾…åŠ©æ¨¡å—)
  - [13.1 Embedding åµŒå…¥æ¨¡å‹](#131-embedding-åµŒå…¥æ¨¡å‹)
  - [13.2 Token è®¡æ•°](#132-token-è®¡æ•°)
  - [13.3 Session ä¼šè¯ç®¡ç†](#133-session-ä¼šè¯ç®¡ç†)
  - [13.4 Tracing è¿½è¸ªç³»ç»Ÿ](#134-tracing-è¿½è¸ªç³»ç»Ÿ)

- [ç¬¬åå››ç« : æ‰§è¡Œæµç¨‹æ·±åº¦å‰–æ](#ç¬¬åå››ç« -æ‰§è¡Œæµç¨‹æ·±åº¦å‰–æ)
  - [14.1 ReActAgent å®Œæ•´æ‰§è¡Œæµ](#141-reactagent-å®Œæ•´æ‰§è¡Œæµ)
  - [14.2 å¤š Agent åä½œæµç¨‹](#142-å¤š-agent-åä½œæµç¨‹)
  - [14.3 å·¥å…·è°ƒç”¨æµç¨‹](#143-å·¥å…·è°ƒç”¨æµç¨‹)

- [ç¬¬åäº”ç« : æ‰©å±•å¼€å‘æŒ‡å—](#ç¬¬åäº”ç« -æ‰©å±•å¼€å‘æŒ‡å—)
  - [15.1 è‡ªå®šä¹‰ Agent](#151-è‡ªå®šä¹‰-agent)
  - [15.2 è‡ªå®šä¹‰å·¥å…·å‡½æ•°](#152-è‡ªå®šä¹‰å·¥å…·å‡½æ•°)
  - [15.3 è‡ªå®šä¹‰ç»„ä»¶](#153-è‡ªå®šä¹‰ç»„ä»¶)

- [ç¬¬åå…­ç« : æœ€ä½³å®è·µä¸ä¼˜åŒ–](#ç¬¬åå…­ç« -æœ€ä½³å®è·µä¸ä¼˜åŒ–)
  - [16.1 æ€§èƒ½ä¼˜åŒ–](#161-æ€§èƒ½ä¼˜åŒ–)
  - [16.2 é”™è¯¯å¤„ç†](#162-é”™è¯¯å¤„ç†)
  - [16.3 æµ‹è¯•ç­–ç•¥](#163-æµ‹è¯•ç­–ç•¥)

---

## ç¬¬ä¸€ç« : é¡¹ç›®æ¦‚è§ˆ

### 1.1 é¡¹ç›®ç®€ä»‹ä¸ç‰¹è‰²

#### 1.1.1 é¡¹ç›®èƒŒæ™¯

**AgentScope** æ˜¯ç”±é˜¿é‡Œå·´å·´é€šä¹‰å®éªŒå®¤ SysML å›¢é˜Ÿå¼€å‘çš„å¼€æºå¤š Agent æ¡†æ¶ã€‚è¯¥é¡¹ç›®å§‹äº 2024 å¹´åˆï¼Œç›®æ ‡æ˜¯ä¸º LLM åº”ç”¨å¼€å‘è€…æä¾›ä¸€ä¸ªé¢å‘ Agent çš„ç¼–ç¨‹èŒƒå¼ï¼Œä½¿å¤æ‚çš„å¤š Agent ç³»ç»Ÿå¼€å‘å˜å¾—ç®€å•ã€é€æ˜ã€å¯æ§ã€‚

#### 1.1.2 æ ¸å¿ƒè®¾è®¡ç†å¿µ

AgentScope çš„è®¾è®¡éµå¾ªä»¥ä¸‹æ ¸å¿ƒç†å¿µï¼š

1. **é€æ˜æ€§ä¼˜å…ˆ (Transparency First)**
   - **ç†å¿µ**: å¼€å‘è€…åº”è¯¥æ¸…æ¥šåœ°çŸ¥é“ç³»ç»Ÿå†…éƒ¨å‘ç”Ÿäº†ä»€ä¹ˆ
   - **å®ç°**: æ‰€æœ‰æ“ä½œéƒ½æ˜¯å¯è§çš„ï¼Œæ²¡æœ‰æ·±åº¦å°è£…çš„"é»‘ç›’"
   - **å¥½å¤„**: æ˜“äºè°ƒè¯•ã€ç†è§£å’Œä¼˜åŒ–
   - **ç¤ºä¾‹**: Agent çš„æ¯æ¬¡æ¨ç†ã€å·¥å…·è°ƒç”¨éƒ½æœ‰æ˜ç¡®çš„æ—¥å¿—å’Œè¿½è¸ª

2. **å¼‚æ­¥ä¼˜å…ˆ (Async First)**
   - **ç†å¿µ**: ç°ä»£ AI åº”ç”¨éœ€è¦å¤„ç†å¤§é‡å¹¶å‘è¯·æ±‚
   - **å®ç°**: æ‰€æœ‰æ ¸å¿ƒæ–¹æ³•éƒ½æ˜¯å¼‚æ­¥çš„(`async/await`)
   - **å¥½å¤„**: é«˜å¹¶å‘æ€§èƒ½ã€éé˜»å¡æ‰§è¡Œã€æ”¯æŒæµå¼è¾“å‡º
   - **ç¤ºä¾‹**:
     ```python
     # å¹¶è¡Œæ‰§è¡Œå¤šä¸ª Agent
     results = await asyncio.gather(
         agent1(msg),
         agent2(msg),
         agent3(msg)
     )
     ```

3. **é«˜åº¦æ¨¡å—åŒ– (Highly Modular)**
   - **ç†å¿µ**: ç³»ç»Ÿåº”è¯¥åƒä¹é«˜ç§¯æœ¨ä¸€æ ·å¯ç»„åˆ
   - **å®ç°**: æ¸…æ™°çš„æ¨¡å—è¾¹ç•Œï¼Œæ¯ä¸ªç»„ä»¶éƒ½å¯ç‹¬ç«‹æ›¿æ¢
   - **å¥½å¤„**: æ˜“äºæ‰©å±•ã€å®šåˆ¶å’Œæµ‹è¯•
   - **ç¤ºä¾‹**: å¯ä»¥è½»æ¾æ›¿æ¢ Modelã€Memoryã€Formatter ç­‰ç»„ä»¶

4. **å¤š Agent å¯¼å‘ (Multi-Agent Oriented)**
   - **ç†å¿µ**: å¤æ‚ä»»åŠ¡éœ€è¦å¤šä¸ª Agent åä½œ
   - **å®ç°**: æ˜¾å¼æ¶ˆæ¯ä¼ é€’ã€MsgHub å‘å¸ƒ-è®¢é˜…ã€Pipeline ç¼–æ’
   - **å¥½å¤„**: æ”¯æŒå¤æ‚çš„åä½œæ¨¡å¼
   - **ç¤ºä¾‹**:
     ```python
     # ä¸‰ä¸ªä¸“å®¶ Agent è®¨è®ºä¸€ä¸ªé—®é¢˜
     async with MsgHub([expert1, expert2, expert3]) as hub:
         await sequential_pipeline([expert1, expert2, expert3])
     ```

5. **æ¨¡å‹æ— å…³ (Model Agnostic)**
   - **ç†å¿µ**: ä¸ç»‘å®šç‰¹å®šçš„ LLM æä¾›å•†
   - **å®ç°**: ç»Ÿä¸€çš„æ¨¡å‹æ¥å£ï¼Œæ”¯æŒå¤šç§ API
   - **å¥½å¤„**: çµæ´»é€‰æ‹©æœ€é€‚åˆçš„æ¨¡å‹
   - **æ”¯æŒ**: OpenAIã€Anthropicã€é˜¿é‡Œäº‘ã€Googleã€Ollama ç­‰

6. **å®æ—¶æ§åˆ¶ (Real-time Control)**
   - **ç†å¿µ**: å¼€å‘è€…åº”è¯¥èƒ½å¤Ÿå®æ—¶å¹²é¢„ Agent è¡Œä¸º
   - **å®ç°**: é’©å­ç³»ç»Ÿã€ä¸­æ–­æœºåˆ¶
   - **å¥½å¤„**: å¯ä»¥åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¿®æ”¹è¡Œä¸º
   - **ç¤ºä¾‹**: åœ¨å·¥å…·è°ƒç”¨å‰æ£€æŸ¥å¹¶ä¿®æ”¹å‚æ•°

#### 1.1.3 æ ¸å¿ƒç‰¹æ€§è¯¦è§£

**âœ¨ é€æ˜æ€§ (Transparency)**

```python
# æ‰€æœ‰æ“ä½œéƒ½æ˜¯å¯è§çš„
class MyAgent(ReActAgent):
    async def reply(self, msg):
        logger.info(f"Agent {self.name} å¼€å§‹å¤„ç†æ¶ˆæ¯: {msg}")

        # æ¨ç†è¿‡ç¨‹å¯è§
        reasoning_result = await self._reasoning()
        logger.info(f"æ¨ç†ç»“æœ: {reasoning_result}")

        # å·¥å…·è°ƒç”¨å¯è§
        if tool_calls := reasoning_result.get_content_blocks("tool_use"):
            logger.info(f"å‡†å¤‡è°ƒç”¨ {len(tool_calls)} ä¸ªå·¥å…·")

        return await super().reply(msg)
```

**âš¡ å¼‚æ­¥æ€§èƒ½ (Asynchronous Performance)**

```python
# å¹¶è¡Œå·¥å…·è°ƒç”¨
async def _acting(self, tool_calls):
    # å¤šä¸ªå·¥å…·å¹¶è¡Œæ‰§è¡Œï¼Œè€Œä¸æ˜¯é¡ºåºæ‰§è¡Œ
    results = await asyncio.gather(*[
        self.toolkit.call_tool_function(tc)
        for tc in tool_calls
    ])
    return results

# æµå¼è¾“å‡º
async for chunk in agent.reply_stream(msg):
    print(chunk, end="", flush=True)
```

**ğŸ”§ æ¨¡å—åŒ–è®¾è®¡ (Modularity)**

```python
# æ¯ä¸ªç»„ä»¶éƒ½å¯ä»¥ç‹¬ç«‹é…ç½®å’Œæ›¿æ¢
agent = ReActAgent(
    name="assistant",
    model=DashScopeChatModel(...),      # å¯æ›¿æ¢ä¸º OpenAIã€Anthropic ç­‰
    memory=InMemoryMemory(),            # å¯æ›¿æ¢ä¸º Redisã€æ•°æ®åº“ç­‰
    formatter=DashScopeChatFormatter(), # å¯æ›¿æ¢ä¸ºå…¶ä»–æ ¼å¼åŒ–å™¨
    toolkit=Toolkit(),                  # å¯è‡ªå®šä¹‰å·¥å…·é›†
    long_term_memory=Mem0LTM(...),     # å¯é€‰çš„é•¿æœŸè®°å¿†
    knowledge=[kb1, kb2],               # å¯é€‰çš„çŸ¥è¯†åº“
    plan_notebook=PlanNotebook()        # å¯é€‰çš„è§„åˆ’ç³»ç»Ÿ
)
```

**ğŸ¤– å¤š Agent åä½œ (Multi-Agent Collaboration)**

AgentScope æä¾›ä¸‰ç§ä¸»è¦çš„å¤š Agent åä½œæ¨¡å¼ï¼š

1. **é¡ºåºæ‰§è¡Œ (Sequential)**
   ```python
   # Agent ä¾æ¬¡å¤„ç†ï¼Œå‰ä¸€ä¸ªçš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªçš„è¾“å…¥
   result = await sequential_pipeline([
       preprocessor_agent,
       analyzer_agent,
       summarizer_agent
   ], initial_msg)
   ```

2. **å¹¶è¡Œæ‰§è¡Œ (Parallel/Fanout)**
   ```python
   # æ‰€æœ‰ Agent å¹¶è¡Œå¤„ç†ç›¸åŒè¾“å…¥
   results = await fanout_pipeline([
       expert_a, expert_b, expert_c
   ], query_msg)
   ```

3. **æ¶ˆæ¯ä¸­å¿ƒ (Message Hub)**
   ```python
   # Agent ä¹‹é—´è‡ªåŠ¨å¹¿æ’­æ¶ˆæ¯
   async with MsgHub([agent1, agent2, agent3], announcement=topic_msg) as hub:
       # ä»»ä½• Agent çš„è¾“å‡ºéƒ½ä¼šè‡ªåŠ¨å¹¿æ’­ç»™å…¶ä»– Agent
       await agent1(msg)  # è¾“å‡ºä¼šè‡ªåŠ¨å‘ç»™ agent2 å’Œ agent3
       await agent2()      # agent2 å·²ç»"å¬åˆ°"äº† agent1 çš„å›å¤
   ```

**ğŸ› ï¸ ä¸°å¯Œçš„å·¥å…·ç”Ÿæ€ (Rich Tool Ecosystem)**

- **å†…ç½®å·¥å…·**: Python ä»£ç æ‰§è¡Œã€Shell å‘½ä»¤ã€æ–‡ä»¶æ“ä½œ
- **MCP åè®®**: è¿æ¥å¤–éƒ¨å·¥å…·æœåŠ¡å™¨
- **è‡ªå®šä¹‰å·¥å…·**: ç®€å•çš„è£…é¥°å™¨å³å¯æ³¨å†Œ
- **å·¥å…·ç»„ç®¡ç†**: åŠ¨æ€æ¿€æ´»/åœç”¨å·¥å…·ç»„

```python
# ç®€å•æ³¨å†Œè‡ªå®šä¹‰å·¥å…·
@toolkit.register_tool_function
def my_calculator(a: int, b: int) -> int:
    """è®¡ç®—ä¸¤ä¸ªæ•°çš„å’Œ

    Args:
        a: ç¬¬ä¸€ä¸ªæ•°
        b: ç¬¬äºŒä¸ªæ•°
    """
    return a + b

# MCP å·¥å…·é›†æˆ
await toolkit.register_mcp_client(mcp_client)
```

**ğŸ¯ å®æ—¶æ§åˆ¶ä¸ä¸­æ–­ (Real-time Control)**

```python
# é’©å­å‡½æ•°å…è®¸åœ¨ä»»ä½•ç¯èŠ‚æ’å…¥è‡ªå®šä¹‰é€»è¾‘
def check_and_modify_tools(self, kwargs):
    """åœ¨å·¥å…·è°ƒç”¨å‰æ£€æŸ¥å‚æ•°"""
    tool_calls = kwargs.get("tool_calls", [])

    for tc in tool_calls:
        if tc["name"] == "dangerous_operation":
            # é˜»æ­¢å±é™©æ“ä½œ
            raise ValueError("æ­¤æ“ä½œéœ€è¦äººå·¥ç¡®è®¤")

    return kwargs

# æ³¨å†Œé’©å­
ReActAgent.register_class_hook(
    "pre_acting",
    "safety_check",
    check_and_modify_tools
)
```

#### 1.1.4 åº”ç”¨åœºæ™¯

AgentScope é€‚ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š

**å• Agent åº”ç”¨**:
- æ™ºèƒ½å®¢æœæœºå™¨äºº
- ä»£ç åŠ©æ‰‹
- å†…å®¹ç”Ÿæˆå·¥å…·
- æ•°æ®åˆ†æåŠ©æ‰‹
- ä¸ªäººåŠ©ç†

**å¤š Agent åº”ç”¨**:
- å›¢é˜Ÿåä½œæ¨¡æ‹Ÿï¼ˆå¦‚ä¼šè®®è®¨è®ºï¼‰
- å¤šè§’è‰²æ¸¸æˆï¼ˆå¦‚ç‹¼äººæ€ï¼‰
- å¤æ‚å†³ç­–ç³»ç»Ÿ
- ç ”ç©¶å›¢é˜Ÿæ¨¡æ‹Ÿ
- è¾©è®ºç³»ç»Ÿ

**ä¼ä¸šçº§åº”ç”¨**:
- æ™ºèƒ½å®¢æœç³»ç»Ÿ
- çŸ¥è¯†ç®¡ç†å¹³å°
- è‡ªåŠ¨åŒ–å·¥ä½œæµ
- æ–‡æ¡£å¤„ç†ç³»ç»Ÿ
- ç ”ç©¶åŠ©æ‰‹

---

### 1.2 æŠ€æœ¯æ ˆä¸ä¾èµ–

#### 1.2.1 æ ¸å¿ƒæŠ€æœ¯æ ˆ

**Python ç‰ˆæœ¬è¦æ±‚**: Python 3.10+

AgentScope é€‰æ‹© Python 3.10+ çš„åŸå› ï¼š
- **ç±»å‹æ³¨è§£å¢å¼º**: `X | Y` è¯­æ³•ã€`TypedDict` æ”¹è¿›
- **æ¨¡å¼åŒ¹é…**: `match-case` è¯­å¥
- **æ›´å¥½çš„é”™è¯¯æ¶ˆæ¯**: æå‡å¼€å‘ä½“éªŒ
- **æ€§èƒ½ä¼˜åŒ–**: CPython æ€§èƒ½æå‡

**æ ¸å¿ƒä¾èµ–åº“**:

```python
# å¼‚æ­¥ç¼–ç¨‹
aioitertools>=0.11.0    # å¼‚æ­¥è¿­ä»£å·¥å…·
asyncio                 # Python å†…ç½®å¼‚æ­¥åº“

# LLM API å®¢æˆ·ç«¯
anthropic>=0.36.0       # Anthropic Claude API
dashscope>=1.20.0       # é˜¿é‡Œäº‘é€šä¹‰åƒé—® API
openai>=1.47.0          # OpenAI API
google-genai            # Google Gemini API (å¯é€‰)
ollama                  # Ollama æœ¬åœ°æ¨¡å‹ (å¯é€‰)

# MCP åè®®
mcp>=1.0.0             # Model Context Protocol

# è¿½è¸ªä¸ç›‘æ§
opentelemetry-api      # åˆ†å¸ƒå¼è¿½è¸ª API
opentelemetry-sdk      # è¿½è¸ª SDK
opentelemetry-exporter-otlp  # OTLP å¯¼å‡ºå™¨

# Token å¤„ç†
tiktoken>=0.8.0        # OpenAI Token è®¡æ•°å™¨

# æ•°æ®éªŒè¯
pydantic>=2.0.0        # æ•°æ®éªŒè¯åº“

# å…¶ä»–
shortuuid              # ç”ŸæˆçŸ­ UUID
docstring_parser       # è§£æå‡½æ•°æ–‡æ¡£å­—ç¬¦ä¸²
```

**å¯é€‰ä¾èµ–**:

```python
# RAG ç›¸å…³
pypdf>=4.0.0           # PDF æ–‡ä»¶å¤„ç†
nltk>=3.8.0            # è‡ªç„¶è¯­è¨€å¤„ç†
qdrant-client>=1.7.0   # Qdrant å‘é‡æ•°æ®åº“å®¢æˆ·ç«¯

# é•¿æœŸè®°å¿†
mem0ai>=0.1.0          # Mem0 è®°å¿†å¹³å°

# è¯„ä¼°
ray>=2.0.0             # åˆ†å¸ƒå¼è®¡ç®—

# HuggingFace æ¨¡å‹
transformers>=4.0.0    # Transformer æ¨¡å‹åº“
torch>=2.0.0           # PyTorch

# Web å·¥å…·
beautifulsoup4         # HTML è§£æ
requests               # HTTP è¯·æ±‚
```

#### 1.2.2 ä¾èµ–å®‰è£…

**åŸºç¡€å®‰è£…**:
```bash
pip install agentscope
```

**å®Œæ•´å®‰è£…**:
```bash
pip install "agentscope[full]"
```

**æŒ‰éœ€å®‰è£…**:
```bash
# RAG åŠŸèƒ½
pip install "agentscope[rag]"

# é•¿æœŸè®°å¿†
pip install "agentscope[mem0]"

# è¯„ä¼°åŠŸèƒ½
pip install "agentscope[eval]"

# HuggingFace æ”¯æŒ
pip install "agentscope[huggingface]"

# å¼€å‘å·¥å…·
pip install "agentscope[dev]"
```

#### 1.2.3 æ¶æ„å±‚æ¬¡

AgentScope é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      åº”ç”¨å±‚ (Application Layer)          â”‚
â”‚  ç”¨æˆ·è‡ªå®šä¹‰ Agentã€å·¥å…·ã€å·¥ä½œæµ           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æ¡†æ¶å±‚ (Framework Layer)            â”‚
â”‚  Agentã€Pipelineã€Planã€RAG             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æ ¸å¿ƒå±‚ (Core Layer)                 â”‚
â”‚  Modelã€Memoryã€Toolã€Formatter         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      åŸºç¡€å±‚ (Foundation Layer)           â”‚
â”‚  Messageã€StateModuleã€Utils            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.3 é¡¹ç›®ç›®å½•ç»“æ„

#### 1.3.1 å®Œæ•´ç›®å½•æ ‘

```
agentscope/
â”œâ”€â”€ src/agentscope/              # æ ¸å¿ƒæºç ç›®å½•
â”‚   â”œâ”€â”€ __init__.py             # åŒ…åˆå§‹åŒ–ï¼Œå¯¼å‡ºä¸»è¦ API
â”‚   â”œâ”€â”€ _logging.py             # æ—¥å¿—é…ç½®
â”‚   â”œâ”€â”€ _constants.py           # å¸¸é‡å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ agent/                  # Agent å®ç°
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _agent_base.py      # AgentBase åŸºç±» (300+ è¡Œ)
â”‚   â”‚   â”œâ”€â”€ _agent_meta.py      # Agent å…ƒç±»ï¼Œå¤„ç†é’©å­ç»§æ‰¿
â”‚   â”‚   â”œâ”€â”€ _react_agent_base.py # ReActAgentBase åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _react_agent.py     # ReActAgent å®Œæ•´å®ç° (500+ è¡Œ)
â”‚   â”‚   â”œâ”€â”€ _user_agent.py      # UserAgent ç”¨æˆ·äº¤äº’
â”‚   â”‚   â””â”€â”€ _user_input.py      # ç”¨æˆ·è¾“å…¥å¤„ç†å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ model/                  # æ¨¡å‹æ¥å£
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _model_base.py      # ChatModelBase åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _model_response.py  # ChatResponse å“åº”ç±»
â”‚   â”‚   â”œâ”€â”€ _model_usage.py     # ä½¿ç”¨ç»Ÿè®¡
â”‚   â”‚   â”œâ”€â”€ _dashscope_model.py # é˜¿é‡Œäº‘é€šä¹‰åƒé—®
â”‚   â”‚   â”œâ”€â”€ _openai_model.py    # OpenAI GPT ç³»åˆ—
â”‚   â”‚   â”œâ”€â”€ _anthropic_model.py # Anthropic Claude
â”‚   â”‚   â”œâ”€â”€ _ollama_model.py    # Ollama æœ¬åœ°æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ _gemini_model.py    # Google Gemini
â”‚   â”‚   â””â”€â”€ _huggingface_model.py # HuggingFace æ¨¡å‹
â”‚   â”‚
â”‚   â”œâ”€â”€ message/                # æ¶ˆæ¯ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _message_base.py    # Msg ç±» (200+ è¡Œ)
â”‚   â”‚   â””â”€â”€ _message_block.py   # å†…å®¹å—å®šä¹‰ (TextBlock, ImageBlock ç­‰)
â”‚   â”‚
â”‚   â”œâ”€â”€ tool/                   # å·¥å…·ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _toolkit.py         # Toolkit ç®¡ç†å™¨ (600+ è¡Œ)
â”‚   â”‚   â”œâ”€â”€ _response.py        # ToolResponse ç±»
â”‚   â”‚   â”œâ”€â”€ _registered_tool_function.py  # å·²æ³¨å†Œå·¥å…·åŒ…è£…
â”‚   â”‚   â”œâ”€â”€ _async_wrapper.py   # å¼‚æ­¥åŒ…è£…å™¨
â”‚   â”‚   â”œâ”€â”€ _coding/            # ä»£ç æ‰§è¡Œå·¥å…·
â”‚   â”‚   â”‚   â”œâ”€â”€ _python.py      # Python ä»£ç æ‰§è¡Œ
â”‚   â”‚   â”‚   â””â”€â”€ _shell.py       # Shell å‘½ä»¤æ‰§è¡Œ
â”‚   â”‚   â”œâ”€â”€ _text_file/         # æ–‡ä»¶æ“ä½œå·¥å…·
â”‚   â”‚   â”‚   â”œâ”€â”€ _view_text_file.py
â”‚   â”‚   â”‚   â”œâ”€â”€ _write_text_file.py
â”‚   â”‚   â”‚   â”œâ”€â”€ _insert_text_file.py
â”‚   â”‚   â”‚   â””â”€â”€ _utils.py
â”‚   â”‚   â””â”€â”€ _multi_modality/    # å¤šæ¨¡æ€å·¥å…·
â”‚   â”‚       â”œâ”€â”€ _dashscope_tools.py  # é€šä¹‰ä¸‡ç›¸ã€å¬æ‚Ÿç­‰
â”‚   â”‚       â””â”€â”€ _openai_tools.py     # DALL-Eã€Whisper ç­‰
â”‚   â”‚
â”‚   â”œâ”€â”€ formatter/              # æç¤ºè¯æ ¼å¼åŒ–
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _formatter_base.py  # FormatterBase åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _truncated_formatter_base.py  # æˆªæ–­æ ¼å¼åŒ–å™¨
â”‚   â”‚   â”œâ”€â”€ _dashscope_formatter.py  # é€šä¹‰åƒé—®æ ¼å¼
â”‚   â”‚   â”œâ”€â”€ _openai_formatter.py     # OpenAI æ ¼å¼
â”‚   â”‚   â”œâ”€â”€ _anthropic_formatter.py  # Anthropic æ ¼å¼
â”‚   â”‚   â”œâ”€â”€ _gemini_formatter.py     # Gemini æ ¼å¼
â”‚   â”‚   â”œâ”€â”€ _ollama_formatter.py     # Ollama æ ¼å¼
â”‚   â”‚   â””â”€â”€ _deepseek_formatter.py   # DeepSeek æ ¼å¼
â”‚   â”‚
â”‚   â”œâ”€â”€ memory/                 # è®°å¿†ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _memory_base.py     # MemoryBase åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _in_memory_memory.py # å†…å­˜è®°å¿†å®ç°
â”‚   â”‚   â”œâ”€â”€ _long_term_memory_base.py  # é•¿æœŸè®°å¿†åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _mem0_long_term_memory.py  # Mem0 é›†æˆ
â”‚   â”‚   â””â”€â”€ _mem0_utils.py      # Mem0 å·¥å…·å‡½æ•°
â”‚   â”‚
â”‚   â”œâ”€â”€ pipeline/               # å·¥ä½œæµç¼–æ’
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _msghub.py          # MsgHub æ¶ˆæ¯ä¸­å¿ƒ (200+ è¡Œ)
â”‚   â”‚   â”œâ”€â”€ _class.py           # Pipeline ç±» (Sequentialã€Fanout)
â”‚   â”‚   â””â”€â”€ _functional.py      # å‡½æ•°å¼ Pipeline
â”‚   â”‚
â”‚   â”œâ”€â”€ plan/                   # è§„åˆ’ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _plan_model.py      # Plan å’Œ SubTask æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ _plan_notebook.py   # PlanNotebook ä¸»ç±» (400+ è¡Œ)
â”‚   â”‚   â”œâ”€â”€ _storage_base.py    # PlanStorageBase å­˜å‚¨åŸºç±»
â”‚   â”‚   â””â”€â”€ _in_memory_storage.py  # å†…å­˜å­˜å‚¨å®ç°
â”‚   â”‚
â”‚   â”œâ”€â”€ rag/                    # RAG æ£€ç´¢å¢å¼º
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _document.py        # Document æ–‡æ¡£æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ _knowledge_base.py  # KnowledgeBase åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _simple_knowledge.py # SimpleKnowledgeBase å®ç°
â”‚   â”‚   â”œâ”€â”€ _reader/            # æ–‡æ¡£è¯»å–å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ _reader_base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ _text_reader.py  # æ–‡æœ¬æ–‡ä»¶è¯»å–
â”‚   â”‚   â”‚   â”œâ”€â”€ _pdf_reader.py   # PDF è¯»å–
â”‚   â”‚   â”‚   â””â”€â”€ _image_reader.py # å›¾ç‰‡è¯»å–
â”‚   â”‚   â””â”€â”€ _store/             # å‘é‡å­˜å‚¨
â”‚   â”‚       â”œâ”€â”€ _store_base.py
â”‚   â”‚       â””â”€â”€ _qdrant_store.py  # Qdrant å‘é‡æ•°æ®åº“
â”‚   â”‚
â”‚   â”œâ”€â”€ mcp/                    # MCP åè®®
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _client_base.py     # MCPClientBase åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _mcp_function.py    # MCP å·¥å…·å‡½æ•°åŒ…è£…
â”‚   â”‚   â”œâ”€â”€ _stateful_client_base.py  # æœ‰çŠ¶æ€å®¢æˆ·ç«¯åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _stdio_stateful_client.py # StdIO å®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ _http_stateless_client.py # HTTP æ— çŠ¶æ€å®¢æˆ·ç«¯
â”‚   â”‚   â””â”€â”€ _http_stateful_client.py  # HTTP æœ‰çŠ¶æ€å®¢æˆ·ç«¯
â”‚   â”‚
â”‚   â”œâ”€â”€ session/                # ä¼šè¯ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _session_base.py    # SessionBase åŸºç±»
â”‚   â”‚   â””â”€â”€ _json_session.py    # JSON æ–‡ä»¶ä¼šè¯
â”‚   â”‚
â”‚   â”œâ”€â”€ embedding/              # åµŒå…¥æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _embedding_base.py  # EmbeddingModelBase
â”‚   â”‚   â”œâ”€â”€ _dashscope_embedding.py  # é€šä¹‰åµŒå…¥
â”‚   â”‚   â”œâ”€â”€ _openai_embedding.py     # OpenAI åµŒå…¥
â”‚   â”‚   â””â”€â”€ _cache.py           # åµŒå…¥ç¼“å­˜
â”‚   â”‚
â”‚   â”œâ”€â”€ token/                  # Token å¤„ç†
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _token_counter_base.py  # Token è®¡æ•°å™¨åŸºç±»
â”‚   â”‚   â”œâ”€â”€ _openai_counter.py      # OpenAI è®¡æ•°å™¨
â”‚   â”‚   â”œâ”€â”€ _anthropic_counter.py   # Anthropic è®¡æ•°å™¨
â”‚   â”‚   â””â”€â”€ _gemini_counter.py      # Gemini è®¡æ•°å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ evaluate/               # è¯„ä¼°æ¡†æ¶
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _evaluator.py       # Evaluator è¯„ä¼°å™¨
â”‚   â”‚   â”œâ”€â”€ _task.py            # Task ä»»åŠ¡å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ _solution.py        # Solution è§£å†³æ–¹æ¡ˆ
â”‚   â”‚   â””â”€â”€ _ray_evaluator.py   # åˆ†å¸ƒå¼è¯„ä¼°
â”‚   â”‚
â”‚   â”œâ”€â”€ tracing/                # è¿½è¸ªç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _trace.py           # è¿½è¸ªè£…é¥°å™¨
â”‚   â”‚   â”œâ”€â”€ _setup.py           # è¿½è¸ªè®¾ç½®
â”‚   â”‚   â””â”€â”€ _exporter.py        # è¿½è¸ªå¯¼å‡ºå™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ hooks/                  # é’©å­ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ _studio_hooks.py    # AgentScope Studio é’©å­
â”‚   â”‚   â””â”€â”€ _logging_hooks.py   # æ—¥å¿—é’©å­
â”‚   â”‚
â”‚   â”œâ”€â”€ module/                 # åŸºç¡€æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ _state_module.py    # StateModule çŠ¶æ€ç®¡ç†åŸºç±»
â”‚   â”‚
â”‚   â”œâ”€â”€ exception/              # å¼‚å¸¸å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ _exception.py       # å„ç§å¼‚å¸¸ç±»
â”‚   â”‚
â”‚   â”œâ”€â”€ types/                  # ç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ _types.py           # TypedDict å’Œ Protocol å®šä¹‰
â”‚   â”‚
â”‚   â””â”€â”€ _utils/                 # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ _common.py          # é€šç”¨å·¥å…·
â”‚       â”œâ”€â”€ _json_schema.py     # JSON Schema ç”Ÿæˆ
â”‚       â””â”€â”€ _docstring.py       # æ–‡æ¡£å­—ç¬¦ä¸²è§£æ
â”‚
â”œâ”€â”€ examples/                   # ç¤ºä¾‹ä»£ç 
â”‚   â”œâ”€â”€ conversation/           # å¯¹è¯ç¤ºä¾‹
â”‚   â”œâ”€â”€ game/                   # æ¸¸æˆç¤ºä¾‹ (ç‹¼äººæ€ç­‰)
â”‚   â”œâ”€â”€ pipeline/               # Pipeline ç¤ºä¾‹
â”‚   â”œâ”€â”€ rag/                    # RAG ç¤ºä¾‹
â”‚   â””â”€â”€ plan/                   # è§„åˆ’ç¤ºä¾‹
â”‚
â”œâ”€â”€ tests/                      # æµ‹è¯•ä»£ç 
â”‚   â”œâ”€â”€ agent/
â”‚   â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ tool/
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ docs/                       # æ–‡æ¡£
â”‚   â”œâ”€â”€ sphinx/                 # Sphinx æ–‡æ¡£æºç 
â”‚   â”œâ”€â”€ tutorial/               # æ•™ç¨‹
â”‚   â””â”€â”€ api/                    # API æ–‡æ¡£
â”‚
â”œâ”€â”€ scripts/                    # è¾…åŠ©è„šæœ¬
â”‚   â”œâ”€â”€ install/                # å®‰è£…è„šæœ¬
â”‚   â””â”€â”€ lint/                   # ä»£ç æ£€æŸ¥è„šæœ¬
â”‚
â”œâ”€â”€ setup.py                    # å®‰è£…é…ç½®
â”œâ”€â”€ pyproject.toml              # é¡¹ç›®é…ç½®
â”œâ”€â”€ README.md                   # é¡¹ç›®è¯´æ˜
â”œâ”€â”€ LICENSE                     # è®¸å¯è¯ (Apache 2.0)
â””â”€â”€ .gitignore                  # Git å¿½ç•¥æ–‡ä»¶
```

#### 1.3.2 æ¨¡å—ç»„ç»‡åŸåˆ™

AgentScope çš„ç›®å½•ç»„ç»‡éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š

1. **å•ä¸€èŒè´£**: æ¯ä¸ªç›®å½•/æ–‡ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½æ¨¡å—
2. **åˆ†å±‚æ¸…æ™°**: åŸºç¡€å±‚ â†’ æ ¸å¿ƒå±‚ â†’ æ¡†æ¶å±‚ â†’ åº”ç”¨å±‚
3. **ä¾èµ–æ–¹å‘**: é«˜å±‚ä¾èµ–ä½å±‚ï¼Œä½å±‚ä¸ä¾èµ–é«˜å±‚
4. **å‘½åè§„èŒƒ**:
   - ç§æœ‰æ¨¡å—ä»¥ `_` å¼€å¤´ (å¦‚ `_agent_base.py`)
   - å…¬å…± API åœ¨ `__init__.py` ä¸­å¯¼å‡º
   - ç±»åä½¿ç”¨å¤§é©¼å³° (å¦‚ `ReActAgent`)
   - å‡½æ•°åä½¿ç”¨å°å†™ä¸‹åˆ’çº¿ (å¦‚ `register_tool_function`)

---

### 1.4 åˆå§‹åŒ–ä¸é…ç½®

#### 1.4.1 åˆå§‹åŒ–å‡½æ•°

**æ–‡ä»¶ä½ç½®**: `src/agentscope/__init__.py`

```python
def init(
    project: str | None = None,
    name: str | None = None,
    logging_path: str | None = None,
    logging_level: str = "INFO",
    studio_url: str | None = None,
    tracing_url: str | None = None,
    save_code: bool = False,
    save_api_invoke: bool = False,
    use_monitor: bool = True,
    cache_dir: str | None = None,
) -> None:
    """åˆå§‹åŒ– AgentScope æ¡†æ¶

    Args:
        project: é¡¹ç›®åç§°ï¼Œç”¨äºç»„ç»‡æ—¥å¿—å’Œè¿½è¸ªæ•°æ®
        name: è¿è¡Œåç§°ï¼Œæ ‡è¯†ä¸€æ¬¡è¿è¡Œå®ä¾‹
        logging_path: æ—¥å¿—æ–‡ä»¶ä¿å­˜è·¯å¾„
        logging_level: æ—¥å¿—çº§åˆ« (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        studio_url: AgentScope Studio URLï¼Œç”¨äºå¯è§†åŒ–å’Œäº¤äº’
        tracing_url: OpenTelemetry è¿½è¸ªç«¯ç‚¹ URL
        save_code: æ˜¯å¦ä¿å­˜ä»£ç å¿«ç…§
        save_api_invoke: æ˜¯å¦ä¿å­˜ API è°ƒç”¨è®°å½•
        use_monitor: æ˜¯å¦å¯ç”¨èµ„æºç›‘æ§
        cache_dir: ç¼“å­˜ç›®å½•ï¼ˆç”¨äº Embedding ç­‰ï¼‰
    """
```

**è®¾è®¡ç†å¿µ**:

1. **å…¨å±€é…ç½®**: ä¸€æ¬¡åˆå§‹åŒ–ï¼Œå…¨å±€ç”Ÿæ•ˆ
2. **å¯é€‰å‚æ•°**: æ‰€æœ‰å‚æ•°éƒ½æ˜¯å¯é€‰çš„ï¼Œæœ‰åˆç†çš„é»˜è®¤å€¼
3. **çµæ´»æ€§**: å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€è°ƒæ•´æŸäº›é…ç½®

**å†…éƒ¨å®ç°**:

```python
def init(
    project: str | None = None,
    name: str | None = None,
    **kwargs
) -> None:
    # 1. è®¾ç½®é¡¹ç›®å’Œè¿è¡Œåç§°
    _runtime.project = project or "default_project"
    _runtime.name = name or f"run_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

    # 2. é…ç½®æ—¥å¿—ç³»ç»Ÿ
    _setup_logging(
        logging_path=kwargs.get("logging_path"),
        logging_level=kwargs.get("logging_level", "INFO")
    )

    # 3. åˆå§‹åŒ–è¿½è¸ªç³»ç»Ÿ
    if tracing_url := kwargs.get("tracing_url"):
        from agentscope.tracing import setup_tracing
        setup_tracing(
            endpoint=tracing_url,
            service_name=_runtime.project
        )

    # 4. è¿æ¥ Studio (å¦‚æœæä¾›)
    if studio_url := kwargs.get("studio_url"):
        from agentscope.hooks import setup_studio_hooks
        setup_studio_hooks(studio_url)

    # 5. åˆ›å»ºç¼“å­˜ç›®å½•
    if cache_dir := kwargs.get("cache_dir"):
        os.makedirs(cache_dir, exist_ok=True)
        _runtime.cache_dir = cache_dir

    logger.info(f"AgentScope åˆå§‹åŒ–å®Œæˆ: project={_runtime.project}, name={_runtime.name}")
```

#### 1.4.2 ä½¿ç”¨ç¤ºä¾‹

**æœ€ç®€å•çš„åˆå§‹åŒ–**:
```python
import agentscope

# ä½¿ç”¨é»˜è®¤é…ç½®
agentscope.init()
```

**å¼€å‘ç¯å¢ƒåˆå§‹åŒ–**:
```python
import agentscope

agentscope.init(
    project="my_chatbot",
    name="debug_run_001",
    logging_level="DEBUG",
    logging_path="./logs"
)
```

**ç”Ÿäº§ç¯å¢ƒåˆå§‹åŒ–**:
```python
import agentscope

agentscope.init(
    project="production_chatbot",
    name=f"prod_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
    logging_level="WARNING",
    logging_path="/var/log/agentscope",
    tracing_url="http://jaeger:4317",  # Jaeger è¿½è¸ª
    save_api_invoke=True,               # ä¿å­˜ API è°ƒç”¨
    cache_dir="/var/cache/agentscope"
)
```

**ä¸ Studio é›†æˆ**:
```python
import agentscope

agentscope.init(
    project="interactive_demo",
    name="studio_session_001",
    studio_url="http://localhost:5000",  # Studio åœ°å€
    logging_level="INFO"
)

# ä¹‹åæ‰€æœ‰ UserAgent çš„è¾“å…¥éƒ½ä¼šä» Studio è·å–
# æ‰€æœ‰ Agent çš„è¾“å‡ºéƒ½ä¼šå‘é€åˆ° Studio æ˜¾ç¤º
```

#### 1.4.3 ç¯å¢ƒå˜é‡é…ç½®

AgentScope è¿˜æ”¯æŒé€šè¿‡ç¯å¢ƒå˜é‡è¿›è¡Œé…ç½®ï¼š

```bash
# API Keys
export DASHSCOPE_API_KEY="your_dashscope_key"
export OPENAI_API_KEY="your_openai_key"
export ANTHROPIC_API_KEY="your_anthropic_key"

# é¡¹ç›®é…ç½®
export AGENTSCOPE_PROJECT="my_project"
export AGENTSCOPE_LOGGING_LEVEL="INFO"
export AGENTSCOPE_CACHE_DIR="/tmp/agentscope_cache"

# Studio é…ç½®
export AGENTSCOPE_STUDIO_URL="http://localhost:5000"

# è¿½è¸ªé…ç½®
export AGENTSCOPE_TRACING_URL="http://localhost:4317"
```

ä½¿ç”¨ç¯å¢ƒå˜é‡åï¼Œåˆå§‹åŒ–å¯ä»¥æ›´ç®€å•ï¼š

```python
import agentscope

# è‡ªåŠ¨è¯»å–ç¯å¢ƒå˜é‡
agentscope.init()
```

---

## ç¬¬äºŒç« : æ ¸å¿ƒæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„å›¾

AgentScope é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼Œæ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     åº”ç”¨å±‚ (Application)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ è‡ªå®šä¹‰ Agent  â”‚  â”‚ è‡ªå®šä¹‰å·¥å…·    â”‚  â”‚ å·¥ä½œæµç¼–æ’    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ¡†æ¶å±‚ (Framework)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Pipeline â”‚  â”‚   Plan   â”‚  â”‚   RAG    â”‚  â”‚   MCP    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ ¸å¿ƒå±‚ (Core)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Agent   â”‚  â”‚  Model   â”‚  â”‚   Tool   â”‚  â”‚  Memory  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚Formatter â”‚  â”‚ Embeddingâ”‚  â”‚  Token   â”‚  â”‚  Tracing â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     åŸºç¡€å±‚ (Foundation)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Message  â”‚  â”‚StateModuleâ”‚ â”‚Exception â”‚  â”‚   Utils  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.1.1 å„å±‚èŒè´£

**åŸºç¡€å±‚ (Foundation Layer)**:
- **Message**: å®šä¹‰æ¶ˆæ¯ç»“æ„å’Œå†…å®¹å—
- **StateModule**: æä¾›çŠ¶æ€åºåˆ—åŒ–/ååºåˆ—åŒ–èƒ½åŠ›
- **Exception**: å®šä¹‰å¼‚å¸¸ä½“ç³»
- **Utils**: æä¾›é€šç”¨å·¥å…·å‡½æ•°

**æ ¸å¿ƒå±‚ (Core Layer)**:
- **Agent**: Agent çš„åŸºç¡€å®ç°
- **Model**: LLM æ¥å£æŠ½è±¡
- **Tool**: å·¥å…·ç®¡ç†å’Œæ‰§è¡Œ
- **Memory**: è®°å¿†ç®¡ç†
- **Formatter**: æ¶ˆæ¯æ ¼å¼åŒ–
- **Embedding**: å‘é‡åµŒå…¥
- **Token**: Token è®¡æ•°
- **Tracing**: è¿½è¸ªå’Œç›‘æ§

**æ¡†æ¶å±‚ (Framework Layer)**:
- **Pipeline**: å¤š Agent å·¥ä½œæµç¼–æ’
- **Plan**: ä»»åŠ¡è§„åˆ’å’Œåˆ†è§£
- **RAG**: æ£€ç´¢å¢å¼ºç”Ÿæˆ
- **MCP**: Model Context Protocol é›†æˆ

**åº”ç”¨å±‚ (Application Layer)**:
- ç”¨æˆ·è‡ªå®šä¹‰çš„ Agent
- ç”¨æˆ·è‡ªå®šä¹‰çš„å·¥å…·
- ä¸šåŠ¡é€»è¾‘å’Œå·¥ä½œæµ

#### 2.1.2 æ•°æ®æµå›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User   â”‚
â”‚  Input   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  UserAgent   â”‚  (1) è·å–ç”¨æˆ·è¾“å…¥
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ Msg
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ReActAgent                              â”‚
â”‚                                                            â”‚
â”‚  (2) observe(msg)                                         â”‚
â”‚      â””â”€â–º memory.add(msg)                                  â”‚
â”‚                                                            â”‚
â”‚  (3) reply()                                              â”‚
â”‚      â”œâ”€â–º long_term_memory.retrieve() [å¯é€‰]               â”‚
â”‚      â”‚    â””â”€â–º ä» Mem0 æ£€ç´¢å†å²çŸ¥è¯†                         â”‚
â”‚      â”‚                                                     â”‚
â”‚      â”œâ”€â–º knowledge.retrieve() [å¯é€‰]                      â”‚
â”‚      â”‚    â”œâ”€â–º embedding_model(query)                      â”‚
â”‚      â”‚    â””â”€â–º vector_store.search()                       â”‚
â”‚      â”‚                                                     â”‚
â”‚      â”œâ”€â–º plan_notebook.get_hint() [å¯é€‰]                  â”‚
â”‚      â”‚    â””â”€â–º è·å–å½“å‰å­ä»»åŠ¡æç¤º                            â”‚
â”‚      â”‚                                                     â”‚
â”‚      â””â”€â–º ReAct å¾ªç¯ (æœ€å¤š max_iters æ¬¡)                   â”‚
â”‚           â”œâ”€â–º _reasoning()                                â”‚
â”‚           â”‚    â”œâ”€â–º memory.get_memory()                    â”‚
â”‚           â”‚    â”œâ”€â–º formatter.format(msgs, tools)          â”‚
â”‚           â”‚    â”œâ”€â–º model(formatted_msgs)                  â”‚
â”‚           â”‚    â””â”€â–º ChatResponse â†’ Msg                     â”‚
â”‚           â”‚                                                â”‚
â”‚           â”œâ”€â–º æå– tool_calls                             â”‚
â”‚           â”‚                                                â”‚
â”‚           â”œâ”€â–º _acting(tool_calls) [å¦‚æœæœ‰å·¥å…·è°ƒç”¨]        â”‚
â”‚           â”‚    â””â”€â–º toolkit.call_tool_function()           â”‚
â”‚           â”‚         â”œâ”€â–º æŸ¥æ‰¾å·¥å…·å‡½æ•°                       â”‚
â”‚           â”‚         â”œâ”€â–º æ‰§è¡Œ (å¯èƒ½å¹¶è¡Œ)                    â”‚
â”‚           â”‚         â””â”€â–º ToolResponse                      â”‚
â”‚           â”‚                                                â”‚
â”‚           â”œâ”€â–º memory.add(tool_results)                    â”‚
â”‚           â”‚                                                â”‚
â”‚           â””â”€â–º å¦‚æœæ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œé€€å‡ºå¾ªç¯                   â”‚
â”‚                                                            â”‚
â”‚  (4) long_term_memory.record() [å¯é€‰]                     â”‚
â”‚                                                            â”‚
â”‚  (5) broadcast_to_subscribers()                           â”‚
â”‚                                                            â”‚
â”‚  (6) print(response_msg)                                  â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ Msg (Response)
                        â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚   User   â”‚
                  â”‚  Output  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.1.3 æ¨¡å—ä¾èµ–å…³ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¾èµ–å…³ç³»å›¾                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

              AgentBase
                 â”‚
                 â”œâ”€â”€dependsâ”€â”€â–º Message
                 â”œâ”€â”€dependsâ”€â”€â–º StateModule
                 â”œâ”€â”€dependsâ”€â”€â–º MemoryBase
                 â””â”€â”€usesâ”€â”€â”€â”€â–º Hooks
                      â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚            â”‚            â”‚
   ReActAgentBase  UserAgent   CustomAgent
         â”‚
         â”œâ”€â”€dependsâ”€â”€â–º ChatModelBase
         â”œâ”€â”€dependsâ”€â”€â–º FormatterBase
         â”œâ”€â”€dependsâ”€â”€â–º Toolkit
         â”œâ”€â”€dependsâ”€â”€â–º LongTermMemoryBase (å¯é€‰)
         â”œâ”€â”€dependsâ”€â”€â–º KnowledgeBase (å¯é€‰)
         â””â”€â”€dependsâ”€â”€â–º PlanNotebook (å¯é€‰)
                â”‚
           ReActAgent
                â”‚
                â””â”€â”€used byâ”€â”€â–º Pipeline, Plan, etc.
```

**ä¾èµ–è§„åˆ™**:
1. **å•å‘ä¾èµ–**: é«˜å±‚æ¨¡å—ä¾èµ–ä½å±‚æ¨¡å—ï¼Œåä¹‹ä¸æˆç«‹
2. **æ¥å£ä¾èµ–**: ä¾èµ–æŠ½è±¡(åŸºç±»)è€Œéå…·ä½“å®ç°
3. **å¯é€‰ä¾èµ–**: é«˜çº§åŠŸèƒ½(RAGã€Planç­‰)æ˜¯å¯é€‰çš„
4. **å¾ªç¯é¿å…**: æ²¡æœ‰å¾ªç¯ä¾èµ–

---

### 2.2 æ ¸å¿ƒæ¦‚å¿µè¯¦è§£

#### 2.2.1 Agent (æ™ºèƒ½ä½“)

**å®šä¹‰**: Agent æ˜¯ä¸€ä¸ªèƒ½å¤Ÿæ„ŸçŸ¥ç¯å¢ƒã€è‡ªä¸»å†³ç­–å¹¶é‡‡å–è¡ŒåŠ¨çš„å®ä½“ã€‚

**æ ¸å¿ƒç‰¹å¾**:
1. **è‡ªä¸»æ€§ (Autonomy)**: å¯ä»¥ç‹¬ç«‹è¿è¡Œï¼Œæ— éœ€äººå·¥å¹²é¢„
2. **ååº”æ€§ (Reactivity)**: èƒ½æ„ŸçŸ¥ç¯å¢ƒå˜åŒ–å¹¶åšå‡ºå“åº”
3. **ä¸»åŠ¨æ€§ (Proactivity)**: èƒ½ä¸»åŠ¨é‡‡å–è¡ŒåŠ¨è¾¾æˆç›®æ ‡
4. **ç¤¾äº¤æ€§ (Social Ability)**: èƒ½ä¸å…¶ä»– Agent é€šä¿¡åä½œ

**åœ¨ AgentScope ä¸­çš„å®ç°**:

```python
class AgentBase(StateModule):
    """Agent åŸºç±»

    æ ¸å¿ƒèƒ½åŠ›:
    1. observe(msg): æ„ŸçŸ¥ - æ¥æ”¶æ¶ˆæ¯ä½†ä¸å›å¤
    2. reply(msg): å†³ç­– - å¤„ç†æ¶ˆæ¯å¹¶ç”Ÿæˆå›å¤
    3. __call__(msg): æ‰§è¡Œ - å®Œæ•´çš„æ„ŸçŸ¥-å†³ç­–-è¡ŒåŠ¨å¾ªç¯
    4. print(msg): è¡ŒåŠ¨ - è¾“å‡ºæ¶ˆæ¯ç»™ç”¨æˆ·æˆ–å…¶ä»– Agent
    """

    async def observe(self, msg: Msg) -> None:
        """æ„ŸçŸ¥ç¯å¢ƒ - æ¥æ”¶ä¿¡æ¯ä½†ä¸åšå“åº”"""
        await self.memory.add(msg)

    async def reply(self, msg: Msg) -> Msg:
        """å†³ç­–è¿‡ç¨‹ - æ ¸å¿ƒé€»è¾‘,ç”±å­ç±»å®ç°"""
        raise NotImplementedError

    async def __call__(self, msg: Msg) -> Msg:
        """å®Œæ•´å¾ªç¯ - æ„ŸçŸ¥ã€å†³ç­–ã€è¡ŒåŠ¨"""
        # 1. æ„ŸçŸ¥
        await self.observe(msg)

        # 2. å†³ç­–
        response = await self.reply(msg)

        # 3. è¡ŒåŠ¨
        await self.print(response)

        # 4. ç¤¾äº¤ (å¹¿æ’­ç»™è®¢é˜…è€…)
        await self._broadcast_to_subscribers(response)

        return response
```

**Agent ç±»å‹**:

1. **ReActAgent**: ä½¿ç”¨ Reasoning + Acting æ¨¡å¼
   - å¾ªç¯æ‰§è¡Œï¼šæ€è€ƒ â†’ è¡ŒåŠ¨ â†’ è§‚å¯Ÿç»“æœ â†’ æ€è€ƒ...
   - é€‚ç”¨äºéœ€è¦ä½¿ç”¨å·¥å…·çš„å¤æ‚ä»»åŠ¡

2. **UserAgent**: ä¸äººç±»ç”¨æˆ·äº¤äº’
   - ä»ç»ˆç«¯ã€Studio æˆ–è‡ªå®šä¹‰ç•Œé¢è·å–è¾“å…¥
   - é€‚ç”¨äºéœ€è¦äººå·¥å‚ä¸çš„åœºæ™¯

3. **è‡ªå®šä¹‰ Agent**: ç»§æ‰¿ AgentBase å®ç°ç‰¹å®šé€»è¾‘
   - ä¾‹å¦‚: åªåšæ€»ç»“çš„ SummaryAgent
   - ä¾‹å¦‚: ä¸“é—¨åšåˆ†ç±»çš„ ClassifierAgent

#### 2.2.2 Message (æ¶ˆæ¯)

**å®šä¹‰**: Message æ˜¯ Agent ä¹‹é—´é€šä¿¡çš„åŸºæœ¬å•ä½ï¼ŒåŒ…å«å†…å®¹ã€å‘é€è€…ã€è§’è‰²ç­‰ä¿¡æ¯ã€‚

**è®¾è®¡ç†å¿µ**:
1. **ç»Ÿä¸€æ¥å£**: æ‰€æœ‰ Agent ä½¿ç”¨ç›¸åŒçš„æ¶ˆæ¯æ ¼å¼
2. **å¤šæ¨¡æ€**: æ”¯æŒæ–‡æœ¬ã€å›¾ç‰‡ã€éŸ³é¢‘ã€è§†é¢‘ç­‰å¤šç§å†…å®¹ç±»å‹
3. **å¯åºåˆ—åŒ–**: å¯ä»¥ä¿å­˜å’Œæ¢å¤
4. **å¯æ‰©å±•**: å¯ä»¥æ·»åŠ è‡ªå®šä¹‰å…ƒæ•°æ®

**æ¶ˆæ¯ç»“æ„**:

```python
@dataclass
class Msg:
    """æ¶ˆæ¯ç±»

    å±æ€§:
        id: æ¶ˆæ¯å”¯ä¸€æ ‡è¯†
        name: å‘é€è€…åç§°
        content: å†…å®¹(æ–‡æœ¬æˆ–å†…å®¹å—åˆ—è¡¨)
        role: è§’è‰²(user/assistant/system)
        metadata: å…ƒæ•°æ®(å¯é€‰)
        timestamp: æ—¶é—´æˆ³
        invocation_id: è°ƒç”¨æ ‡è¯†(åŒä¸€æ¬¡è°ƒç”¨çš„æ¶ˆæ¯å…±äº«)
    """
    id: str
    name: str
    content: str | Sequence[ContentBlock]
    role: Literal["user", "assistant", "system"]
    metadata: dict | None
    timestamp: str
    invocation_id: str
```

**å†…å®¹å— (Content Blocks)**:

AgentScope æ”¯æŒå¤šç§å†…å®¹å—ï¼Œå®ç°çœŸæ­£çš„å¤šæ¨¡æ€é€šä¿¡ï¼š

```python
# æ–‡æœ¬å—
TextBlock(type="text", text="Hello, world!")

# å›¾ç‰‡å—
ImageBlock(
    type="image",
    source=URLSource(type="url", url="https://example.com/image.jpg")
)

# éŸ³é¢‘å—
AudioBlock(
    type="audio",
    source=Base64Source(
        type="base64",
        media_type="audio/wav",
        data="base64_encoded_data..."
    )
)

# å·¥å…·è°ƒç”¨å—
ToolUseBlock(
    type="tool_use",
    id="call_123",
    name="execute_python_code",
    input={"code": "print('hello')"}
)

# å·¥å…·ç»“æœå—
ToolResultBlock(
    type="tool_result",
    id="call_123",
    output="hello\n"
)

# æ€è€ƒå— (Claude ç­‰æ¨¡å‹æ”¯æŒ)
ThinkingBlock(
    type="thinking",
    thinking="Let me analyze this step by step..."
)
```

**æ¶ˆæ¯ä¼ é€’æ¨¡å¼**:

1. **ç‚¹å¯¹ç‚¹ (Point-to-Point)**
   ```python
   # Agent A å‘ Agent B å‘é€æ¶ˆæ¯
   response = await agent_b(msg)
   ```

2. **å‘å¸ƒ-è®¢é˜… (Pub-Sub)**
   ```python
   # é€šè¿‡ MsgHub, Agent A çš„è¾“å‡ºè‡ªåŠ¨å‘ç»™ B å’Œ C
   async with MsgHub([agent_a, agent_b, agent_c]):
       await agent_a(msg)  # B å’Œ C è‡ªåŠ¨æ”¶åˆ°
   ```

3. **å¹¿æ’­ (Broadcast)**
   ```python
   # æ‰‹åŠ¨å¹¿æ’­ç»™æ‰€æœ‰è®¢é˜…è€…
   await hub.broadcast(msg)
   ```

#### 2.2.3 Tool (å·¥å…·)

**å®šä¹‰**: Tool æ˜¯ Agent å¯ä»¥è°ƒç”¨çš„å¤–éƒ¨åŠŸèƒ½ï¼Œæ‰©å±• Agent çš„èƒ½åŠ›è¾¹ç•Œã€‚

**å·¥å…·å“²å­¦**:
- **èƒ½åŠ›æ‰©å±•**: LLM æœ¬èº«æ— æ³•æ‰§è¡Œä»£ç ã€è®¿é—®ç½‘ç»œã€æ“ä½œæ–‡ä»¶ï¼Œå·¥å…·å¼¥è¡¥è¿™äº›èƒ½åŠ›
- **å¯é æ€§**: å·¥å…·æ‰§è¡Œç¡®å®šæ€§æ“ä½œï¼Œé¿å… LLM å¹»è§‰
- **å¯æ§æ€§**: å·¥å…·æ‰§è¡Œå¯ä»¥è¢«ç›‘æ§ã€é™åˆ¶å’Œå®¡è®¡

**å·¥å…·ç±»å‹**:

1. **å†…ç½®å·¥å…·**: AgentScope æä¾›çš„å·¥å…·
   ```python
   execute_python_code(code="print(2+2)")
   view_text_file(file_path="data.txt")
   dashscope_text_to_image(prompt="a cat")
   ```

2. **è‡ªå®šä¹‰å·¥å…·**: ç”¨æˆ·è‡ªå·±ç¼–å†™çš„å·¥å…·
   ```python
   def my_calculator(a: int, b: int) -> int:
       """è®¡ç®—ä¸¤æ•°ä¹‹å’Œ

       Args:
           a: ç¬¬ä¸€ä¸ªæ•°
           b: ç¬¬äºŒä¸ªæ•°
       """
       return a + b

   toolkit.register_tool_function(my_calculator)
   ```

3. **MCP å·¥å…·**: é€šè¿‡ MCP åè®®è¿æ¥çš„å¤–éƒ¨å·¥å…·
   ```python
   mcp_client = HttpStatelessClient(url="https://mcp.example.com")
   await toolkit.register_mcp_client(mcp_client)
   ```

**å·¥å…·è°ƒç”¨æµç¨‹**:

```
1. LLM å†³å®šè°ƒç”¨å·¥å…·
   â””â”€â–º ChatResponse åŒ…å« ToolUseBlock

2. Agent æå–å·¥å…·è°ƒç”¨
   â””â”€â–º tool_calls = msg.get_content_blocks("tool_use")

3. Toolkit æ‰§è¡Œå·¥å…·
   â”œâ”€â–º æŸ¥æ‰¾å·¥å…·å‡½æ•°
   â”œâ”€â–º éªŒè¯å‚æ•°
   â”œâ”€â–º æ‰§è¡Œå‡½æ•° (å¯èƒ½å¹¶è¡Œ)
   â””â”€â–º è¿”å› ToolResponse

4. å°†ç»“æœæ·»åŠ åˆ°è®°å¿†
   â””â”€â–º memory.add(ToolResultBlock(...))

5. LLM åŸºäºç»“æœç»§ç»­æ¨ç†
   â””â”€â–º ä¸‹ä¸€è½® ReAct å¾ªç¯
```

#### 2.2.4 Memory (è®°å¿†)

**å®šä¹‰**: Memory å­˜å‚¨ Agent çš„å¯¹è¯å†å²å’ŒçŸ¥è¯†ï¼Œä½¿ Agent èƒ½å¤Ÿä¿æŒä¸Šä¸‹æ–‡ã€‚

**è®°å¿†åˆ†ç±»**:

1. **çŸ­æœŸè®°å¿† (Short-term Memory)**
   - **ç”¨é€”**: å­˜å‚¨å½“å‰å¯¹è¯å†å²
   - **å®ç°**: InMemoryMemory (å†…å­˜åˆ—è¡¨)
   - **ç‰¹ç‚¹**: å¿«é€Ÿã€æ˜“å¤±æ€§
   - **ç”Ÿå‘½å‘¨æœŸ**: å¯¹è¯æœŸé—´

2. **é•¿æœŸè®°å¿† (Long-term Memory)**
   - **ç”¨é€”**: å­˜å‚¨æŒä¹…åŒ–çŸ¥è¯†
   - **å®ç°**: Mem0LongTermMemory (åŸºäº Mem0 å¹³å°)
   - **ç‰¹ç‚¹**: æŒä¹…åŒ–ã€å¯æ£€ç´¢
   - **ç”Ÿå‘½å‘¨æœŸ**: è·¨ä¼šè¯

**è®°å¿†æ“ä½œ**:

```python
# çŸ­æœŸè®°å¿†
memory = InMemoryMemory()
await memory.add(msg)                    # æ·»åŠ 
messages = await memory.get_memory()     # è·å–
await memory.clear()                     # æ¸…ç©º

# é•¿æœŸè®°å¿†
ltm = Mem0LongTermMemory(api_key="...")
await ltm.record(messages, agent_id="agent_001")  # è®°å½•
retrieved = await ltm.retrieve(query="...", agent_id="agent_001")  # æ£€ç´¢
```

**è®°å¿†ç®¡ç†ç­–ç•¥**:

AgentScope æä¾›ä¸‰ç§é•¿æœŸè®°å¿†ç®¡ç†æ¨¡å¼ï¼š

1. **agent_control**: Agent è‡ªä¸»æ§åˆ¶
   ```python
   agent = ReActAgent(
       long_term_memory=ltm,
       long_term_memory_mode="agent_control"
   )
   # Agent å¯ä»¥è°ƒç”¨ retrieve_from_memory å’Œ record_to_memory å·¥å…·
   ```

2. **static_control**: è‡ªåŠ¨ç®¡ç†
   ```python
   agent = ReActAgent(
       long_term_memory=ltm,
       long_term_memory_mode="static_control"
   )
   # æ¯æ¬¡ reply() å¼€å§‹æ—¶è‡ªåŠ¨æ£€ç´¢ï¼Œç»“æŸæ—¶è‡ªåŠ¨è®°å½•
   ```

3. **both**: ä¸¤è€…ç»“åˆ
   ```python
   agent = ReActAgent(
       long_term_memory=ltm,
       long_term_memory_mode="both"
   )
   # è‡ªåŠ¨æ£€ç´¢å’Œè®°å½•ï¼ŒAgent ä¹Ÿå¯ä»¥ä¸»åŠ¨è°ƒç”¨
   ```

#### 2.2.5 Pipeline (å·¥ä½œæµ)

**å®šä¹‰**: Pipeline å®šä¹‰äº†å¤šä¸ª Agent çš„åä½œæ–¹å¼å’Œæ‰§è¡Œé¡ºåºã€‚

**Pipeline æ¨¡å¼**:

1. **é¡ºåºæ‰§è¡Œ (Sequential)**
   ```python
   result = await sequential_pipeline([
       agent1, agent2, agent3
   ], initial_msg)

   # æ‰§è¡Œæµç¨‹: agent1 â†’ agent2 â†’ agent3
   ```

2. **å¹¶è¡Œæ‰§è¡Œ (Fanout)**
   ```python
   results = await fanout_pipeline([
       agent1, agent2, agent3
   ], query_msg)

   # æ‰§è¡Œæµç¨‹: agent1 â•‘ agent2 â•‘ agent3 (å¹¶è¡Œ)
   ```

3. **æ¶ˆæ¯ä¸­å¿ƒ (MsgHub)**
   ```python
   async with MsgHub([agent1, agent2, agent3]) as hub:
       await agent1(msg)  # agent1 çš„è¾“å‡ºè‡ªåŠ¨å¹¿æ’­ç»™ agent2 å’Œ agent3
   ```

**å¤æ‚å·¥ä½œæµç¤ºä¾‹**:

```python
async def complex_workflow(query):
    """å¤æ‚çš„åˆ†æå·¥ä½œæµ"""

    # é˜¶æ®µ 1: æ•°æ®é¢„å¤„ç†
    preprocessor = PreprocessorAgent(...)
    preprocessed = await preprocessor(query)

    # é˜¶æ®µ 2: å¹¶è¡Œåˆ†æ
    analyzers = [
        SentimentAgent(...),
        TopicAgent(...),
        EntityAgent(...)
    ]
    analyses = await fanout_pipeline(analyzers, preprocessed)

    # é˜¶æ®µ 3: ä¸“å®¶è®¨è®º
    experts = [ExpertA(...), ExpertB(...), ExpertC(...)]
    async with MsgHub(experts, announcement=analyses) as hub:
        await sequential_pipeline(experts)

    # é˜¶æ®µ 4: æœ€ç»ˆæ€»ç»“
    summarizer = SummarizerAgent(...)
    final_result = await summarizer()

    return final_result
```

---

### 2.3 è®¾è®¡å“²å­¦

#### 2.3.1 æ˜¾å¼ä¼˜äºéšå¼ (Explicit over Implicit)

**ç†å¿µ**: å¼€å‘è€…åº”è¯¥æ˜ç¡®çŸ¥é“ç³»ç»Ÿåšäº†ä»€ä¹ˆï¼Œè€Œä¸æ˜¯ä¾èµ–"é­”æ³•"ã€‚

**ç¤ºä¾‹å¯¹æ¯”**:

```python
# âŒ éšå¼ (ä¸æ¨è)
agent = Agent("gpt-4")  # è°çŸ¥é“å†…éƒ¨å‘ç”Ÿäº†ä»€ä¹ˆ?
response = agent("hello")  # è¿™æ˜¯åŒæ­¥è¿˜æ˜¯å¼‚æ­¥? æœ‰æ²¡æœ‰è°ƒç”¨å·¥å…·?

# âœ… æ˜¾å¼ (AgentScope æ–¹å¼)
agent = ReActAgent(
    name="assistant",
    model=OpenAIChatModel(model_name="gpt-4"),
    memory=InMemoryMemory(),
    formatter=OpenAIChatFormatter(),
    toolkit=Toolkit()
)
response = await agent(Msg("user", "hello", "user"))
# æ¸…æ¥šåœ°çŸ¥é“: è¿™æ˜¯å¼‚æ­¥çš„, ä½¿ç”¨ OpenAI, æœ‰è®°å¿†, å¯ä»¥è°ƒç”¨å·¥å…·
```

**å¥½å¤„**:
- **æ˜“äºç†è§£**: ä»£ç å³æ–‡æ¡£
- **æ˜“äºè°ƒè¯•**: çŸ¥é“åœ¨å“ªé‡ŒæŸ¥æ‰¾é—®é¢˜
- **æ˜“äºæµ‹è¯•**: å¯ä»¥ mock ä»»ä½•ç»„ä»¶

#### 2.3.2 ç»„åˆä¼˜äºç»§æ‰¿ (Composition over Inheritance)

**ç†å¿µ**: é€šè¿‡ç»„åˆç°æœ‰ç»„ä»¶æ„å»ºåŠŸèƒ½ï¼Œè€Œä¸æ˜¯å¤æ‚çš„ç»§æ‰¿å±‚æ¬¡ã€‚

**ç¤ºä¾‹**:

```python
# é€šè¿‡ç»„åˆä¸åŒç»„ä»¶åˆ›å»ºä¸åŒç±»å‹çš„ Agent

# åŸºç¡€å¯¹è¯ Agent
basic_agent = ReActAgent(
    model=model,
    memory=InMemoryMemory(),
    formatter=formatter,
    toolkit=Toolkit()
)

# å¸¦é•¿æœŸè®°å¿†çš„ Agent
ltm_agent = ReActAgent(
    model=model,
    memory=InMemoryMemory(),
    formatter=formatter,
    toolkit=Toolkit(),
    long_term_memory=Mem0LTM(...)  # æ·»åŠ é•¿æœŸè®°å¿†ç»„ä»¶
)

# å¸¦ RAG çš„ Agent
rag_agent = ReActAgent(
    model=model,
    memory=InMemoryMemory(),
    formatter=formatter,
    toolkit=Toolkit(),
    knowledge=[kb1, kb2]  # æ·»åŠ çŸ¥è¯†åº“ç»„ä»¶
)

# å…¨åŠŸèƒ½ Agent
full_agent = ReActAgent(
    model=model,
    memory=InMemoryMemory(),
    formatter=formatter,
    toolkit=Toolkit(),
    long_term_memory=Mem0LTM(...),
    knowledge=[kb1, kb2],
    plan_notebook=PlanNotebook()
)
```

#### 2.3.3 çº¦å®šä¼˜äºé…ç½® (Convention over Configuration)

**ç†å¿µ**: æä¾›åˆç†çš„é»˜è®¤å€¼ï¼Œå‡å°‘å¿…éœ€çš„é…ç½®ã€‚

**ç¤ºä¾‹**:

```python
# æœ€ç®€é…ç½®
agent = ReActAgent(
    name="assistant",
    sys_prompt="You are a helpful assistant",
    model=model,
    formatter=formatter
)
# è‡ªåŠ¨åˆ›å»º: InMemoryMemory(), Toolkit()

# éœ€è¦æ—¶æ‰é…ç½®
agent = ReActAgent(
    name="assistant",
    sys_prompt="You are a helpful assistant",
    model=model,
    formatter=formatter,
    memory=CustomMemory(),  # è‡ªå®šä¹‰è®°å¿†
    toolkit=custom_toolkit,  # è‡ªå®šä¹‰å·¥å…·é›†
    max_iters=20  # è¦†ç›–é»˜è®¤å€¼ 10
)
```

**é»˜è®¤å€¼è®¾è®¡åŸåˆ™**:
- **å®‰å…¨**: é»˜è®¤å€¼åº”è¯¥æ˜¯å®‰å…¨çš„
- **å¸¸ç”¨**: é»˜è®¤å€¼åº”è¯¥é€‚åˆå¤§å¤šæ•°åœºæ™¯
- **å¯è¦†ç›–**: æ‰€æœ‰é»˜è®¤å€¼éƒ½å¯ä»¥è¢«è¦†ç›–

#### 2.3.4 å¤±è´¥å®‰å…¨ (Fail Safe)

**ç†å¿µ**: é”™è¯¯åº”è¯¥å°½æ—©æš´éœ²ï¼Œè€Œä¸æ˜¯é»˜é»˜å¤±è´¥ã€‚

**é”™è¯¯å¤„ç†ç­–ç•¥**:

```python
# 1. ç±»å‹æ£€æŸ¥
async def reply(self, msg: Msg) -> Msg:
    if not isinstance(msg, Msg):
        raise TypeError(f"Expected Msg, got {type(msg)}")
    # ...

# 2. å‚æ•°éªŒè¯
def register_tool_function(self, tool_func):
    if not callable(tool_func):
        raise ValueError("tool_func must be callable")
    if not hasattr(tool_func, "__name__"):
        raise ValueError("tool_func must have a name")
    # ...

# 3. å¼‚å¸¸ä¼ æ’­
async def call_tool_function(self, tool_call):
    try:
        result = await self.tools[tool_name](**kwargs)
    except Exception as e:
        # ä¸æ•è·å¼‚å¸¸ï¼Œè®©å®ƒå‘ä¸Šä¼ æ’­
        logger.error(f"Tool execution failed: {e}")
        raise
```

#### 2.3.5 å¼€æ”¾å°é—­åŸåˆ™ (Open-Closed Principle)

**ç†å¿µ**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­ã€‚

**å®ç°æ–¹å¼**:

1. **æŠ½è±¡åŸºç±»**: å®šä¹‰æ¥å£ï¼Œä¸é™åˆ¶å®ç°
   ```python
   class ChatModelBase(ABC):
       @abstractmethod
       async def __call__(self, messages, **kwargs):
           """å­ç±»å¯ä»¥å®ç°ä»»ä½• LLM"""
   ```

2. **é’©å­ç³»ç»Ÿ**: æ— éœ€ä¿®æ”¹ä»£ç å³å¯æ·»åŠ åŠŸèƒ½
   ```python
   # æ·»åŠ è‡ªå®šä¹‰é€»è¾‘
   def my_logging_hook(self, kwargs):
       logger.info(f"Agent {self.name} called")
       return kwargs

   ReActAgent.register_class_hook("pre_reply", "my_log", my_logging_hook)
   ```

3. **æ’ä»¶å¼å·¥å…·**: åŠ¨æ€æ³¨å†Œå·¥å…·
   ```python
   # æ— éœ€ä¿®æ”¹ Toolkit ä»£ç 
   toolkit.register_tool_function(my_new_tool)
   ```

---

### 2.4 å¼‚æ­¥ä¼˜å…ˆæ¶æ„

#### 2.4.1 ä¸ºä»€ä¹ˆé€‰æ‹©å¼‚æ­¥?

**ä¼ ç»ŸåŒæ­¥æ¨¡å¼çš„é—®é¢˜**:

```python
# åŒæ­¥æ¨¡å¼ - é˜»å¡æ‰§è¡Œ
def agent_call(msg):
    # 1. è°ƒç”¨ LLM (è€—æ—¶ 2 ç§’)
    response = model.generate(msg)  # é˜»å¡ 2 ç§’

    # 2. è°ƒç”¨å·¥å…· (è€—æ—¶ 3 ç§’)
    result = tool.execute()  # é˜»å¡ 3 ç§’

    # 3. å†æ¬¡è°ƒç”¨ LLM (è€—æ—¶ 2 ç§’)
    final = model.generate(result)  # é˜»å¡ 2 ç§’

    return final  # æ€»è€—æ—¶: 2+3+2 = 7 ç§’

# å¹¶å‘è¯·æ±‚ä¼šç›¸äº’é˜»å¡
responses = [agent_call(msg1), agent_call(msg2), agent_call(msg3)]
# æ€»è€—æ—¶: 7*3 = 21 ç§’
```

**å¼‚æ­¥æ¨¡å¼çš„ä¼˜åŠ¿**:

```python
# å¼‚æ­¥æ¨¡å¼ - éé˜»å¡æ‰§è¡Œ
async def agent_call(msg):
    # 1. å¼‚æ­¥è°ƒç”¨ LLM
    response = await model.generate(msg)  # éé˜»å¡

    # 2. å¼‚æ­¥è°ƒç”¨å·¥å…·
    result = await tool.execute()  # éé˜»å¡

    # 3. å†æ¬¡å¼‚æ­¥è°ƒç”¨ LLM
    final = await model.generate(result)  # éé˜»å¡

    return final

# å¹¶å‘è¯·æ±‚å¯ä»¥äº¤é”™æ‰§è¡Œ
responses = await asyncio.gather(
    agent_call(msg1),
    agent_call(msg2),
    agent_call(msg3)
)
# æ€»è€—æ—¶: ~7 ç§’ (å¹¶å‘æ‰§è¡Œ)
```

#### 2.4.2 å¼‚æ­¥æ¶æ„çš„æ ¸å¿ƒç»„ä»¶

**1. å¼‚æ­¥å‡½æ•° (Async Functions)**

æ‰€æœ‰ I/O æ“ä½œéƒ½æ˜¯å¼‚æ­¥çš„ï¼š

```python
class ReActAgent:
    # æ ¸å¿ƒæ–¹æ³•éƒ½æ˜¯å¼‚æ­¥
    async def observe(self, msg): ...
    async def reply(self, msg): ...
    async def print(self, msg): ...

    # å†…éƒ¨æ–¹æ³•ä¹Ÿæ˜¯å¼‚æ­¥
    async def _reasoning(self): ...
    async def _acting(self, tool_calls): ...
```

**2. å¼‚æ­¥è¿­ä»£å™¨ (Async Generators)**

æ”¯æŒæµå¼è¾“å‡ºï¼š

```python
# æ¨¡å‹è¿”å›å¼‚æ­¥ç”Ÿæˆå™¨
async def model_call(messages):
    async for chunk in api.stream(messages):
        yield ChatResponse(content=chunk, stream=True, is_last=False)
    yield ChatResponse(content=final, stream=True, is_last=True)

# Agent å¤„ç†æµå¼å“åº”
async for response in model_call(messages):
    await self.print(response, last=response.is_last)
```

**3. å¹¶å‘æ‰§è¡Œ (Concurrent Execution)**

å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»»åŠ¡ï¼š

```python
# å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå·¥å…·
results = await asyncio.gather(*[
    toolkit.call_tool_function(tc1),
    toolkit.call_tool_function(tc2),
    toolkit.call_tool_function(tc3)
])

# å¹¶è¡Œæ‰§è¡Œå¤šä¸ª Agent
responses = await asyncio.gather(*[
    agent1(msg),
    agent2(msg),
    agent3(msg)
])
```

#### 2.4.3 å¼‚æ­¥æ¨¡å¼æœ€ä½³å®è·µ

**1. å§‹ç»ˆä½¿ç”¨ `await`**

```python
# âŒ é”™è¯¯: å¿˜è®° await
response = agent(msg)  # è¿”å› coroutine å¯¹è±¡ï¼Œè€Œä¸æ˜¯ç»“æœ

# âœ… æ­£ç¡®
response = await agent(msg)
```

**2. åœ¨å¼‚æ­¥å‡½æ•°ä¸­è°ƒç”¨å¼‚æ­¥å‡½æ•°**

```python
# âŒ é”™è¯¯: åœ¨åŒæ­¥å‡½æ•°ä¸­è°ƒç”¨å¼‚æ­¥å‡½æ•°
def process():
    result = await agent(msg)  # SyntaxError

# âœ… æ­£ç¡®
async def process():
    result = await agent(msg)
```

**3. ä½¿ç”¨ `asyncio.gather` å¹¶å‘æ‰§è¡Œ**

```python
# âŒ ä½æ•ˆ: é¡ºåºæ‰§è¡Œ
result1 = await slow_operation1()
result2 = await slow_operation2()
result3 = await slow_operation3()

# âœ… é«˜æ•ˆ: å¹¶å‘æ‰§è¡Œ
results = await asyncio.gather(
    slow_operation1(),
    slow_operation2(),
    slow_operation3()
)
```

**4. é”™è¯¯å¤„ç†**

```python
# å¤„ç†å•ä¸ªå¼‚æ­¥è°ƒç”¨çš„é”™è¯¯
try:
    result = await agent(msg)
except Exception as e:
    logger.error(f"Agent failed: {e}")

# å¤„ç†å¹¶å‘è°ƒç”¨çš„é”™è¯¯
results = await asyncio.gather(
    agent1(msg),
    agent2(msg),
    agent3(msg),
    return_exceptions=True  # è¿”å›å¼‚å¸¸è€Œä¸æ˜¯æŠ›å‡º
)

for i, result in enumerate(results):
    if isinstance(result, Exception):
        logger.error(f"Agent {i} failed: {result}")
```

#### 2.4.4 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**1. é¿å…ä¸å¿…è¦çš„ await**

```python
# âŒ ä½æ•ˆ
async def process():
    data = await load_data()
    await asyncio.sleep(0)  # ä¸å¿…è¦çš„ await
    result = await process_data(data)
    return result

# âœ… é«˜æ•ˆ
async def process():
    data = await load_data()
    result = await process_data(data)  # ç›´æ¥å¤„ç†
    return result
```

**2. ä½¿ç”¨ä»»åŠ¡å¹¶å‘**

```python
# åˆ›å»ºä»»åŠ¡è€Œä¸æ˜¯ç«‹å³ await
task1 = asyncio.create_task(agent1(msg))
task2 = asyncio.create_task(agent2(msg))

# åšå…¶ä»–å·¥ä½œ
do_something_else()

# ç­‰å¾…ç»“æœ
result1 = await task1
result2 = await task2
```

**3. æµå¼å¤„ç†å¤§æ•°æ®**

```python
# âŒ ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰æ•°æ®
async def process_all():
    data = await load_all_data()  # å¯èƒ½å¾ˆå¤§
    for item in data:
        await process(item)

# âœ… æµå¼å¤„ç†
async def process_stream():
    async for item in load_data_stream():
        await process(item)  # é€ä¸ªå¤„ç†
```

---

## ç¬¬ä¸‰ç« : Agent æ¨¡å—æ·±åº¦è§£æ

### 3.1 AgentBase åŸºç±»

**æ–‡ä»¶ä½ç½®**: `src/agentscope/agent/_agent_base.py`

#### 3.1.1 ç±»è®¾è®¡æ¦‚è§ˆ

AgentBase æ˜¯æ‰€æœ‰ Agent çš„åŸºç±»ï¼Œå®šä¹‰äº† Agent çš„æ ¸å¿ƒæ¥å£å’Œè¡Œä¸ºã€‚

**ç»§æ‰¿å…³ç³»**:
```python
AgentBase(StateModule, metaclass=_AgentMeta)
```

**è®¾è®¡ç†å¿µ**:
1. **æœ€å°æ¥å£**: åªå®šä¹‰å¿…é¡»çš„æŠ½è±¡æ–¹æ³•
2. **é’©å­æ‰©å±•**: é€šè¿‡é’©å­ç³»ç»Ÿå®ç°çµæ´»æ‰©å±•
3. **çŠ¶æ€ç®¡ç†**: ç»§æ‰¿ StateModule æ”¯æŒåºåˆ—åŒ–
4. **å…ƒç±»é­”æ³•**: ä½¿ç”¨å…ƒç±»è‡ªåŠ¨å¤„ç†é’©å­ç»§æ‰¿

**æ ¸å¿ƒå±æ€§**:

```python
class AgentBase(StateModule, metaclass=_AgentMeta):
    """Agent åŸºç±»

    æ ¸å¿ƒå±æ€§:
        id: Agent å”¯ä¸€æ ‡è¯† (ä½¿ç”¨ shortuuid ç”Ÿæˆ)
        _subscribers: è®¢é˜…è€…å­—å…¸ {hub_id: [subscribers]}
        _reply_task: å½“å‰æ­£åœ¨æ‰§è¡Œçš„ reply ä»»åŠ¡
        _reply_id: å½“å‰ reply çš„æ ‡è¯†
        _stream_prefix: æµå¼è¾“å‡ºçš„å‰ç¼€ç¼“å­˜
        _disable_console_output: æ˜¯å¦ç¦ç”¨æ§åˆ¶å°è¾“å‡º
        msg_queue: æ¶ˆæ¯é˜Ÿåˆ— (ç”¨äºå¯¼å‡ºæ¶ˆæ¯æµ)
    """

    # ç±»çº§åˆ«çš„é’©å­å­˜å‚¨
    _class_pre_reply_hooks: OrderedDict = OrderedDict()
    _class_post_reply_hooks: OrderedDict = OrderedDict()
    _class_pre_print_hooks: OrderedDict = OrderedDict()
    _class_post_print_hooks: OrderedDict = OrderedDict()
    _class_pre_observe_hooks: OrderedDict = OrderedDict()
    _class_post_observe_hooks: OrderedDict = OrderedDict()

    def __init__(self) -> None:
        super().__init__()
        self.id = shortuuid.uuid()

        # å®ä¾‹çº§åˆ«çš„é’©å­å­˜å‚¨
        self._instance_pre_reply_hooks = OrderedDict()
        self._instance_post_reply_hooks = OrderedDict()
        # ... å…¶ä»–é’©å­

        # è®¢é˜…è€…ç®¡ç†
        self._subscribers: dict[str, list[AgentBase]] = {}

        # æµå¼è¾“å‡ºç¼“å­˜
        self._stream_prefix = {}
```

#### 3.1.2 æ ¸å¿ƒæ–¹æ³•è¯¦è§£

**1. observe() - è§‚å¯Ÿæ–¹æ³•**

**åŠŸèƒ½**: æ¥æ”¶æ¶ˆæ¯ä½†ä¸ç”Ÿæˆå›å¤ï¼Œç”¨äºè®© Agent "å¬åˆ°"å…¶ä»– Agent çš„æ¶ˆæ¯ã€‚

**è®¾è®¡ç†å¿µ**:
- **è¢«åŠ¨æ„ŸçŸ¥**: Agent è¢«åŠ¨æ¥æ”¶ä¿¡æ¯
- **æ— å‰¯ä½œç”¨**: åªè®°å½•ï¼Œä¸å›å¤
- **é’©å­æ”¯æŒ**: æ”¯æŒ pre/post é’©å­

**å®ç°**:
```python
async def observe(self, msg: Msg | list[Msg] | None) -> None:
    """è§‚å¯Ÿæ¶ˆæ¯

    æ‰§è¡Œæµç¨‹:
    1. æ‰§è¡Œ pre_observe é’©å­
    2. å°†æ¶ˆæ¯æ·»åŠ åˆ°è®°å¿† (å­ç±»å®ç°)
    3. æ‰§è¡Œ post_observe é’©å­

    Args:
        msg: è¦è§‚å¯Ÿçš„æ¶ˆæ¯
    """
    if msg is None:
        return

    # å‡†å¤‡å‚æ•°
    kwargs = {"msg": msg}

    # æ‰§è¡Œ pre_observe é’©å­
    kwargs = await self._execute_hooks("pre_observe", kwargs)

    # è°ƒç”¨å­ç±»å®ç°
    await self._observe_impl(kwargs["msg"])

    # æ‰§è¡Œ post_observe é’©å­
    await self._execute_hooks("post_observe", {"msg": kwargs["msg"]})
```

**ä½¿ç”¨åœºæ™¯**:
```python
# åœºæ™¯ 1: MsgHub è‡ªåŠ¨è°ƒç”¨
async with MsgHub([agent1, agent2, agent3]) as hub:
    await agent1(msg)
    # agent2 å’Œ agent3 è‡ªåŠ¨è°ƒç”¨ observe(agent1_response)

# åœºæ™¯ 2: æ‰‹åŠ¨è®© Agent è§‚å¯Ÿ
expert_msg = await expert(query)
await observer.observe(expert_msg)  # observer è®°å½•ä½†ä¸å›å¤
```

**2. reply() - å›å¤æ–¹æ³•**

**åŠŸèƒ½**: Agent çš„æ ¸å¿ƒé€»è¾‘ï¼Œç”Ÿæˆå¯¹è¾“å…¥çš„å›å¤ã€‚

**è®¾è®¡ç†å¿µ**:
- **æŠ½è±¡æ–¹æ³•**: å¿…é¡»ç”±å­ç±»å®ç°
- **å¼‚æ­¥æ‰§è¡Œ**: æ”¯æŒå¹¶å‘
- **çµæ´»è¾“å…¥**: æ¥å—ä»»æ„å‚æ•°

**ç­¾å**:
```python
@abstractmethod
async def reply(self, *args: Any, **kwargs: Any) -> Msg:
    """ç”Ÿæˆå›å¤ (ç”±å­ç±»å®ç°)

    Args:
        *args: ä½ç½®å‚æ•°
        **kwargs: å…³é”®å­—å‚æ•°

    Returns:
        Msg: å›å¤æ¶ˆæ¯
    """
    raise NotImplementedError
```

**å­ç±»å®ç°ç¤ºä¾‹**:
```python
# ReActAgent çš„å®ç°
async def reply(
    self,
    msg: Msg | list[Msg] | None = None,
    structured_model: Type[BaseModel] | None = None
) -> Msg:
    """ReAct å¾ªç¯å®ç°"""

    # 1. æ·»åŠ åˆ°è®°å¿†
    await self.memory.add(msg)

    # 2. é•¿æœŸè®°å¿†æ£€ç´¢ (å¦‚æœå¯ç”¨)
    if self._static_control:
        retrieved = await self.long_term_memory.retrieve(...)
        await self.memory.add(Msg("system", retrieved, "system"))

    # 3. çŸ¥è¯†åº“æ£€ç´¢ (å¦‚æœå¯ç”¨)
    for kb in self.knowledge:
        docs = await kb.retrieve(...)

    # 4. ReAct å¾ªç¯
    for i in range(self.max_iters):
        # æ¨ç†
        msg_reasoning = await self._reasoning(structured_model)

        # æå–å·¥å…·è°ƒç”¨
        tool_calls = msg_reasoning.get_content_blocks("tool_use")

        if tool_calls:
            # æ‰§è¡Œå·¥å…·
            await self._acting(tool_calls)
        else:
            # æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œç»“æŸå¾ªç¯
            reply_msg = msg_reasoning
            break

    # 5. è®°å½•åˆ°é•¿æœŸè®°å¿† (å¦‚æœå¯ç”¨)
    if self._static_control:
        await self.long_term_memory.record(...)

    return reply_msg
```

**3. __call__() - è°ƒç”¨æ–¹æ³•**

**åŠŸèƒ½**: Agent çš„å®Œæ•´æ‰§è¡Œæµç¨‹ï¼ŒåŒ…æ‹¬é’©å­ã€å¹¿æ’­ã€æ‰“å°ç­‰ã€‚

**è®¾è®¡ç†å¿µ**:
- **å®Œæ•´æµç¨‹**: å°†æ‰€æœ‰æ­¥éª¤ç»„åˆåœ¨ä¸€èµ·
- **é’©å­é›†æˆ**: åœ¨å…³é”®ç‚¹æ‰§è¡Œé’©å­
- **æ¶ˆæ¯ä¼ æ’­**: è‡ªåŠ¨å¹¿æ’­ç»™è®¢é˜…è€…

**å®ç°**:
```python
async def __call__(self, *args: Any, **kwargs: Any) -> Msg:
    """å®Œæ•´çš„ Agent æ‰§è¡Œæµç¨‹

    æ‰§è¡Œæ­¥éª¤:
    1. æ‰§è¡Œ pre_reply é’©å­
    2. è°ƒç”¨ reply() ç”Ÿæˆå›å¤
    3. æ‰§è¡Œ post_reply é’©å­
    4. å¹¿æ’­ç»™è®¢é˜…è€…
    5. æ‰“å°æ¶ˆæ¯
    6. è¿”å›ç»“æœ
    """
    # 1. å‡†å¤‡å‚æ•°
    call_kwargs = kwargs.copy()

    # 2. æ‰§è¡Œ pre_reply é’©å­
    call_kwargs = await self._execute_hooks("pre_reply", call_kwargs)

    # 3. è°ƒç”¨ reply()
    response = await self.reply(*args, **call_kwargs)

    # 4. æ‰§è¡Œ post_reply é’©å­
    response = await self._execute_hooks(
        "post_reply",
        {"kwargs": call_kwargs, "output": response}
    )

    # 5. å¹¿æ’­ç»™è®¢é˜…è€…
    await self._broadcast_to_subscribers(response)

    # 6. æ‰“å°æ¶ˆæ¯
    await self.print(response)

    return response
```

**ä½¿ç”¨æ–¹å¼**:
```python
# æ–¹å¼ 1: ç›´æ¥è°ƒç”¨
response = await agent(msg)

# æ–¹å¼ 2: ä½œä¸ºå‡½æ•°ä½¿ç”¨
agent_func = agent
response = await agent_func(msg)

# æ–¹å¼ 3: åœ¨ Pipeline ä¸­ä½¿ç”¨
result = await sequential_pipeline([agent1, agent2, agent3], msg)
```

**4. print() - æ‰“å°æ–¹æ³•**

**åŠŸèƒ½**: æ˜¾ç¤ºæ¶ˆæ¯ï¼Œæ”¯æŒæµå¼è¾“å‡ºã€‚

**è®¾è®¡ç†å¿µ**:
- **å¯é…ç½®**: å¯ä»¥ç¦ç”¨è¾“å‡º
- **æµå¼æ”¯æŒ**: æ”¯æŒæµå¼æ¶ˆæ¯çš„å¢é‡æ˜¾ç¤º
- **é’©å­æ‰©å±•**: å¯ä»¥é€šè¿‡é’©å­ä¿®æ”¹è¾“å‡ºè¡Œä¸º

**å®ç°**:
```python
async def print(self, msg: Msg, last: bool = True) -> None:
    """æ‰“å°æ¶ˆæ¯

    Args:
        msg: è¦æ‰“å°çš„æ¶ˆæ¯
        last: æ˜¯å¦æ˜¯æµå¼æ¶ˆæ¯çš„æœ€åä¸€å—
    """
    if self._disable_console_output:
        return

    kwargs = {"msg": msg, "last": last}

    # æ‰§è¡Œ pre_print é’©å­
    kwargs = await self._execute_hooks("pre_print", kwargs)

    # å®é™…æ‰“å°é€»è¾‘
    await self._print_impl(kwargs["msg"], kwargs["last"])

    # æ‰§è¡Œ post_print é’©å­
    await self._execute_hooks("post_print", kwargs)

async def _print_impl(self, msg: Msg, last: bool) -> None:
    """å®é™…æ‰“å°é€»è¾‘"""

    # å¤„ç†æµå¼è¾“å‡º
    if hasattr(msg, "stream") and msg.stream and not last:
        # æµå¼è¾“å‡ºï¼šç´¯ç§¯æ˜¾ç¤º
        if msg.id not in self._stream_prefix:
            self._stream_prefix[msg.id] = {"text": "", "audio": None}

        # æå–æ–‡æœ¬å†…å®¹
        text = msg.get_text_content()
        if text:
            # åªæ‰“å°æ–°å¢çš„éƒ¨åˆ†
            new_text = text[len(self._stream_prefix[msg.id]["text"]):]
            print(new_text, end="", flush=True)
            self._stream_prefix[msg.id]["text"] = text
    else:
        # éæµå¼æˆ–æœ€åä¸€å—ï¼šå®Œæ•´æ‰“å°
        print(f"\n{msg.name}: {msg.get_text_content()}")

        # æ¸…ç†æµå¼ç¼“å­˜
        if msg.id in self._stream_prefix:
            del self._stream_prefix[msg.id]
```

**æµå¼è¾“å‡ºç¤ºä¾‹**:
```python
# Agent ç”Ÿæˆæµå¼å“åº”
async for chunk in agent.reply_stream(msg):
    await agent.print(chunk, last=chunk.is_last)

# è¾“å‡ºæ•ˆæœ:
# Agent: Hello,      (ç¬¬ä¸€å—)
# Agent: Hello, how  (ç¬¬äºŒå—ï¼Œåªæ‰“å° " how")
# Agent: Hello, how are you? (æœ€åä¸€å—ï¼Œåªæ‰“å° " are you?")
```

#### 3.1.3 è®¢é˜…è€…æœºåˆ¶

**è®¾è®¡ç›®çš„**: å®ç° Agent é—´çš„è‡ªåŠ¨æ¶ˆæ¯ä¼ æ’­ã€‚

**æ ¸å¿ƒæ–¹æ³•**:

```python
def set_subscribers(
    self,
    hub_id: str,
    subscribers: list[AgentBase]
) -> None:
    """è®¾ç½®è®¢é˜…è€…

    Args:
        hub_id: MsgHub çš„æ ‡è¯†
        subscribers: è®¢é˜…è€…åˆ—è¡¨
    """
    self._subscribers[hub_id] = subscribers

def remove_subscribers(self, hub_id: str) -> None:
    """ç§»é™¤è®¢é˜…è€…ç»„"""
    if hub_id in self._subscribers:
        del self._subscribers[hub_id]

async def _broadcast_to_subscribers(self, msg: Msg) -> None:
    """å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰è®¢é˜…è€…"""
    for subscribers in self._subscribers.values():
        await asyncio.gather(*[
            subscriber.observe(msg)
            for subscriber in subscribers
        ])
```

**å·¥ä½œåŸç†**:

```python
# MsgHub è®¾ç½®è®¢é˜…å…³ç³»
async with MsgHub([agent1, agent2, agent3]) as hub:
    # hub å†…éƒ¨è°ƒç”¨:
    # agent1.set_subscribers(hub.id, [agent2, agent3])
    # agent2.set_subscribers(hub.id, [agent1, agent3])
    # agent3.set_subscribers(hub.id, [agent1, agent2])

    # å½“ agent1 å›å¤æ—¶
    response = await agent1(msg)
    # agent1.__call__() å†…éƒ¨è‡ªåŠ¨è°ƒç”¨:
    # await agent1._broadcast_to_subscribers(response)
    # è¿™ä¼šè‡ªåŠ¨è®© agent2 å’Œ agent3 è§‚å¯Ÿåˆ°è¿™æ¡æ¶ˆæ¯
```

#### 3.1.4 çŠ¶æ€ç®¡ç†

AgentBase ç»§æ‰¿è‡ª StateModuleï¼Œæ”¯æŒå®Œæ•´çš„çŠ¶æ€åºåˆ—åŒ–ã€‚

**å¯åºåˆ—åŒ–çš„çŠ¶æ€**:
```python
def state_dict(self) -> dict:
    """åºåˆ—åŒ– Agent çŠ¶æ€"""
    return {
        "id": self.id,
        "class_name": self.__class__.__name__,
        "subscribers": {
            hub_id: [agent.id for agent in agents]
            for hub_id, agents in self._subscribers.items()
        },
        # å­ç±»æ·»åŠ æ›´å¤šçŠ¶æ€
    }

def load_state_dict(self, state_dict: dict) -> None:
    """åŠ è½½ Agent çŠ¶æ€"""
    self.id = state_dict["id"]
    # è®¢é˜…è€…éœ€è¦åœ¨åŠ è½½åé‡æ–°è¿æ¥
    # å­ç±»åŠ è½½æ›´å¤šçŠ¶æ€
```

**ä½¿ç”¨ç¤ºä¾‹**:
```python
# ä¿å­˜ Agent çŠ¶æ€
state = agent.state_dict()
with open("agent_state.json", "w") as f:
    json.dump(state, f)

# åŠ è½½ Agent çŠ¶æ€
with open("agent_state.json", "r") as f:
    state = json.load(f)

new_agent = ReActAgent(...)  # åˆ›å»ºç›¸åŒç±»å‹çš„ Agent
new_agent.load_state_dict(state)
```

---

### 3.2 é’©å­ç³»ç»Ÿè¯¦è§£

#### 3.2.1 é’©å­ç³»ç»Ÿè®¾è®¡ç†å¿µ

**ä»€ä¹ˆæ˜¯é’©å­?**
é’©å­(Hook)æ˜¯åœ¨ç‰¹å®šæ‰§è¡Œç‚¹æ’å…¥è‡ªå®šä¹‰é€»è¾‘çš„æœºåˆ¶ï¼Œç±»ä¼¼äºäº‹ä»¶ç›‘å¬å™¨ã€‚

**ä¸ºä»€ä¹ˆéœ€è¦é’©å­?**
1. **æ— ä¾µå…¥æ‰©å±•**: ä¸ä¿®æ”¹æºä»£ç å³å¯æ·»åŠ åŠŸèƒ½
2. **å…³æ³¨ç‚¹åˆ†ç¦»**: å°†æ ¸å¿ƒé€»è¾‘å’Œè¾…åŠ©åŠŸèƒ½åˆ†ç¦»
3. **çµæ´»é…ç½®**: å¯ä»¥åŠ¨æ€æ·»åŠ /ç§»é™¤é’©å­
4. **å¯ç»„åˆ**: å¤šä¸ªé’©å­å¯ä»¥é“¾å¼æ‰§è¡Œ

**è®¾è®¡æ¨¡å¼**: è§‚å¯Ÿè€…æ¨¡å¼ + è´£ä»»é“¾æ¨¡å¼

#### 3.2.2 æ”¯æŒçš„é’©å­ç±»å‹

AgentBase æ”¯æŒ 6 ç§é’©å­ï¼š

```python
supported_hook_types = [
    "pre_reply",     # reply() æ‰§è¡Œå‰
    "post_reply",    # reply() æ‰§è¡Œå
    "pre_print",     # print() æ‰§è¡Œå‰
    "post_print",    # print() æ‰§è¡Œå
    "pre_observe",   # observe() æ‰§è¡Œå‰
    "post_observe",  # observe() æ‰§è¡Œå
]
```

ReActAgentBase é¢å¤–æ”¯æŒï¼š

```python
supported_hook_types = [
    *AgentBase.supported_hook_types,
    "pre_reasoning",   # _reasoning() æ‰§è¡Œå‰
    "post_reasoning",  # _reasoning() æ‰§è¡Œå
    "pre_acting",      # _acting() æ‰§è¡Œå‰
    "post_acting",     # _acting() æ‰§è¡Œå
]
```

#### 3.2.3 é’©å­å‡½æ•°ç­¾å

**pre_* é’©å­**:
```python
def pre_hook(
    self: AgentBase,           # Agent å®ä¾‹
    kwargs: dict[str, Any]     # æ–¹æ³•çš„å‚æ•°å­—å…¸
) -> dict[str, Any] | None:    # è¿”å›ä¿®æ”¹åçš„å‚æ•°æˆ– None
    """å‰ç½®é’©å­

    åŠŸèƒ½:
    - æ£€æŸ¥/ä¿®æ”¹å‚æ•°
    - è®°å½•æ—¥å¿—
    - æ‰§è¡Œé¢„å¤„ç†

    è¿”å›:
    - dict: ä¿®æ”¹åçš„å‚æ•°ï¼Œä¼ é€’ç»™ä¸‹ä¸€ä¸ªé’©å­æˆ–åŸæ–¹æ³•
    - None: ä¸ä¿®æ”¹å‚æ•°
    """
    # ç¤ºä¾‹ï¼šè®°å½•è°ƒç”¨
    logger.info(f"Agent {self.name} called with {kwargs}")

    # ç¤ºä¾‹ï¼šä¿®æ”¹å‚æ•°
    if "msg" in kwargs:
        kwargs["msg"] = preprocess(kwargs["msg"])

    return kwargs
```

**post_* é’©å­**:
```python
def post_hook(
    self: AgentBase,           # Agent å®ä¾‹
    kwargs: dict[str, Any],    # åŸå§‹å‚æ•°
    output: Any                # æ–¹æ³•çš„è¾“å‡º
) -> Any | None:               # è¿”å›ä¿®æ”¹åçš„è¾“å‡ºæˆ– None
    """åç½®é’©å­

    åŠŸèƒ½:
    - æ£€æŸ¥/ä¿®æ”¹è¾“å‡º
    - è®°å½•ç»“æœ
    - æ‰§è¡Œåå¤„ç†

    è¿”å›:
    - Any: ä¿®æ”¹åçš„è¾“å‡ºï¼Œä¼ é€’ç»™ä¸‹ä¸€ä¸ªé’©å­æˆ–è°ƒç”¨è€…
    - None: ä¸ä¿®æ”¹è¾“å‡º
    """
    # ç¤ºä¾‹ï¼šè®°å½•ç»“æœ
    logger.info(f"Agent {self.name} returned {output}")

    # ç¤ºä¾‹ï¼šä¿®æ”¹è¾“å‡º
    if isinstance(output, Msg):
        output = postprocess(output)

    return output
```

#### 3.2.4 æ³¨å†Œé’©å­

**ç±»çº§é’©å­** (å½±å“è¯¥ç±»çš„æ‰€æœ‰å®ä¾‹):

```python
# æ–¹æ³• 1: ä½¿ç”¨ç±»æ–¹æ³•
ReActAgent.register_class_hook(
    hook_type="pre_reply",
    hook_name="my_logging_hook",
    hook_func=my_logging_hook
)

# æ–¹æ³• 2: ç›´æ¥æ“ä½œå­—å…¸ (ä¸æ¨è)
ReActAgent._class_pre_reply_hooks["my_hook"] = my_hook_func
```

**å®ä¾‹çº§é’©å­** (åªå½±å“å½“å‰å®ä¾‹):

```python
# åˆ›å»º Agent å®ä¾‹
agent = ReActAgent(...)

# æ³¨å†Œå®ä¾‹çº§é’©å­
agent.register_instance_hook(
    hook_type="post_reply",
    hook_name="my_hook",
    hook_func=my_hook_func
)
```

**é’©å­æ‰§è¡Œé¡ºåº**:
```
ç±»çº§é’©å­ (æŒ‰æ³¨å†Œé¡ºåº) â†’ å®ä¾‹çº§é’©å­ (æŒ‰æ³¨å†Œé¡ºåº)
```

#### 3.2.5 é’©å­å®æˆ˜ç¤ºä¾‹

**ç¤ºä¾‹ 1: æ—¥å¿—è®°å½•é’©å­**

```python
def logging_pre_reply_hook(self, kwargs):
    """è®°å½•æ¯æ¬¡ Agent è°ƒç”¨"""
    logger.info(f"[{datetime.now()}] Agent {self.name} started")
    logger.debug(f"Input: {kwargs}")
    return kwargs

def logging_post_reply_hook(self, kwargs, output):
    """è®°å½•æ¯æ¬¡ Agent å“åº”"""
    logger.info(f"[{datetime.now()}] Agent {self.name} finished")
    logger.debug(f"Output: {output}")
    return output

# å…¨å±€æ³¨å†Œ
ReActAgent.register_class_hook("pre_reply", "logging_pre", logging_pre_reply_hook)
ReActAgent.register_class_hook("post_reply", "logging_post", logging_post_reply_hook)
```

**ç¤ºä¾‹ 2: æ€§èƒ½ç›‘æ§é’©å­**

```python
import time

def performance_pre_hook(self, kwargs):
    """è®°å½•å¼€å§‹æ—¶é—´"""
    kwargs["_start_time"] = time.time()
    return kwargs

def performance_post_hook(self, kwargs, output):
    """è®¡ç®—æ‰§è¡Œæ—¶é—´"""
    if "_start_time" in kwargs:
        elapsed = time.time() - kwargs["_start_time"]
        logger.info(f"Agent {self.name} took {elapsed:.2f}s")
    return output

ReActAgent.register_class_hook("pre_reply", "perf_start", performance_pre_hook)
ReActAgent.register_class_hook("post_reply", "perf_end", performance_post_hook)
```

**ç¤ºä¾‹ 3: æ¶ˆæ¯è¿‡æ»¤é’©å­**

```python
def content_filter_hook(self, kwargs):
    """è¿‡æ»¤æ•æ„Ÿå†…å®¹"""
    if "msg" in kwargs:
        msg = kwargs["msg"]
        text = msg.get_text_content()

        # æ£€æŸ¥æ•æ„Ÿè¯
        if contains_sensitive_words(text):
            logger.warning(f"Blocked sensitive content from {msg.name}")
            # ä¿®æ”¹æ¶ˆæ¯
            kwargs["msg"] = Msg(
                msg.name,
                "[æ­¤æ¶ˆæ¯åŒ…å«æ•æ„Ÿå†…å®¹å·²è¢«è¿‡æ»¤]",
                msg.role
            )

    return kwargs

# ä¸ºç‰¹å®š Agent æ³¨å†Œ
important_agent.register_instance_hook(
    "pre_reply",
    "content_filter",
    content_filter_hook
)
```

**ç¤ºä¾‹ 4: å·¥å…·è°ƒç”¨å®¡è®¡é’©å­**

```python
def tool_audit_pre_hook(self, kwargs):
    """å®¡è®¡å·¥å…·è°ƒç”¨"""
    tool_calls = kwargs.get("tool_calls", [])

    for tc in tool_calls:
        logger.info(f"Agent {self.name} calling tool: {tc['name']}")

        # æ£€æŸ¥å±é™©æ“ä½œ
        if tc["name"] in ["execute_shell_command", "write_file"]:
            # éœ€è¦äººå·¥ç¡®è®¤
            confirmation = input(f"Allow {tc['name']}? (y/n): ")
            if confirmation.lower() != "y":
                raise PermissionError(f"Tool {tc['name']} blocked by user")

    return kwargs

ReActAgent.register_class_hook("pre_acting", "tool_audit", tool_audit_pre_hook)
```

**ç¤ºä¾‹ 5: è‡ªåŠ¨é‡è¯•é’©å­**

```python
def auto_retry_hook(self, kwargs, output):
    """è‡ªåŠ¨é‡è¯•å¤±è´¥çš„è°ƒç”¨"""
    # æ£€æŸ¥æ˜¯å¦å¤±è´¥
    if isinstance(output, Msg):
        text = output.get_text_content()
        if "error" in text.lower() or "failed" in text.lower():
            logger.warning(f"Agent {self.name} failed, retrying...")

            # é‡è¯• (æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–äº†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„é€»è¾‘)
            # return self.reply(**kwargs)  # é€’å½’å¯èƒ½å¯¼è‡´é—®é¢˜

            # æ›´å¥½çš„åšæ³•æ˜¯åœ¨å¤–å±‚æ•è·å¹¶é‡è¯•
            output.metadata = output.metadata or {}
            output.metadata["needs_retry"] = True

    return output

# æ³¨å†Œåç½®é’©å­
agent.register_instance_hook("post_reply", "auto_retry", auto_retry_hook)
```

#### 3.2.6 é’©å­çš„é«˜çº§ç”¨æ³•

**æ¡ä»¶é’©å­**:

```python
def conditional_hook(self, kwargs):
    """åªåœ¨ç‰¹å®šæ¡ä»¶ä¸‹æ‰§è¡Œ"""
    # åªåœ¨åŒ…å«ç‰¹å®šå…³é”®è¯æ—¶è®°å½•
    if "msg" in kwargs:
        text = kwargs["msg"].get_text_content()
        if "important" in text.lower():
            logger.critical(f"Important message detected: {text}")

    return kwargs
```

**é’©å­ç»„åˆ**:

```python
# å®šä¹‰å¤šä¸ªé’©å­å®ç°ä¸åŒåŠŸèƒ½
hooks = [
    ("logging", logging_hook),
    ("performance", performance_hook),
    ("audit", audit_hook),
    ("retry", retry_hook),
]

# æ‰¹é‡æ³¨å†Œ
for name, func in hooks:
    ReActAgent.register_class_hook("pre_reply", name, func)
```

**ç§»é™¤é’©å­**:

```python
# ç§»é™¤ç±»çº§é’©å­
if "my_hook" in ReActAgent._class_pre_reply_hooks:
    del ReActAgent._class_pre_reply_hooks["my_hook"]

# ç§»é™¤å®ä¾‹çº§é’©å­
if "my_hook" in agent._instance_pre_reply_hooks:
    del agent._instance_pre_reply_hooks["my_hook"]
```

---

### 3.3 ReActAgent å®ç°

**æ–‡ä»¶ä½ç½®**: `src/agentscope/agent/_react_agent.py`

#### 3.3.1 ReAct æ¨¡å¼ä»‹ç»

**ä»€ä¹ˆæ˜¯ ReAct?**

ReAct = **Rea**soning + **Act**ing

è¿™æ˜¯ä¸€ç§è®© LLM äº¤æ›¿è¿›è¡Œæ¨ç†(Reasoning)å’Œè¡ŒåŠ¨(Acting)çš„èŒƒå¼ï¼Œç‰¹åˆ«é€‚åˆéœ€è¦ä½¿ç”¨å·¥å…·çš„å¤æ‚ä»»åŠ¡ã€‚

**ä¼ ç»Ÿæ¨¡å¼ vs ReAct æ¨¡å¼**:

```
ä¼ ç»Ÿæ¨¡å¼:
ç”¨æˆ·è¾“å…¥ â†’ LLM ç›´æ¥å›ç­” â†’ ç»“æŸ
é—®é¢˜: LLM ä¸èƒ½è®¿é—®å®æ—¶ä¿¡æ¯ã€æ‰§è¡Œä»£ç ã€æ“ä½œæ–‡ä»¶ç­‰

ReAct æ¨¡å¼:
ç”¨æˆ·è¾“å…¥ â†’ LLM æ¨ç†(æ€è€ƒä¸‹ä¸€æ­¥) â†’ è°ƒç”¨å·¥å…· â†’ è§‚å¯Ÿç»“æœ â†’
         LLM æ¨ç†(åŸºäºç»“æœæ€è€ƒ) â†’ è°ƒç”¨å·¥å…· â†’ è§‚å¯Ÿç»“æœ â†’
         ... (å¾ªç¯) ...
         LLM æ¨ç†(ç»™å‡ºæœ€ç»ˆç­”æ¡ˆ) â†’ ç»“æŸ
ä¼˜åŠ¿: LLM å¯ä»¥ä½¿ç”¨å·¥å…·æ‰©å±•èƒ½åŠ›è¾¹ç•Œ
```

**ReAct ç¤ºä¾‹**:

```
ç”¨æˆ·: ä»Šå¤©åŒ—äº¬çš„å¤©æ°”æ€ä¹ˆæ ·?

å¾ªç¯ 1:
  æ¨ç†: æˆ‘éœ€è¦æŸ¥è¯¢å¤©æ°”ä¿¡æ¯
  è¡ŒåŠ¨: è°ƒç”¨ get_weather(city="åŒ—äº¬")
  è§‚å¯Ÿ: {"temperature": 15, "condition": "æ™´"}

å¾ªç¯ 2:
  æ¨ç†: å·²è·å¾—å¤©æ°”ä¿¡æ¯ï¼Œå¯ä»¥å›ç­”ç”¨æˆ·
  è¡ŒåŠ¨: è°ƒç”¨ generate_response(response="ä»Šå¤©åŒ—äº¬å¤©æ°”æ™´æœ—ï¼Œæ¸©åº¦15åº¦")
  è§‚å¯Ÿ: (ç»“æŸ)

è¾“å‡º: ä»Šå¤©åŒ—äº¬å¤©æ°”æ™´æœ—ï¼Œæ¸©åº¦15åº¦
```

#### 3.3.2 ReActAgent åˆå§‹åŒ–

**å®Œæ•´çš„åˆå§‹åŒ–å‚æ•°**:

```python
def __init__(
    self,
    name: str,                          # Agent åç§°
    sys_prompt: str,                    # ç³»ç»Ÿæç¤º
    model: ChatModelBase,               # LLM æ¨¡å‹
    formatter: FormatterBase,           # æ¶ˆæ¯æ ¼å¼åŒ–å™¨
    toolkit: Toolkit | None = None,    # å·¥å…·åŒ…
    memory: MemoryBase | None = None,  # çŸ­æœŸè®°å¿†
    long_term_memory: LongTermMemoryBase | None = None,  # é•¿æœŸè®°å¿†
    long_term_memory_mode: Literal[
        "agent_control",      # Agent è‡ªä¸»æ§åˆ¶
        "static_control",     # è‡ªåŠ¨æ§åˆ¶
        "both",              # ä¸¤è€…ç»“åˆ
    ] = "both",
    enable_meta_tool: bool = False,    # æ˜¯å¦å¯ç”¨å…ƒå·¥å…·
    parallel_tool_calls: bool = False, # æ˜¯å¦å¹¶è¡Œæ‰§è¡Œå·¥å…·
    knowledge: KnowledgeBase | list[KnowledgeBase] | None = None,  # çŸ¥è¯†åº“
    enable_rewrite_query: bool = True,  # æ˜¯å¦é‡å†™æŸ¥è¯¢
    plan_notebook: PlanNotebook | None = None,  # è®¡åˆ’ç¬”è®°æœ¬
    print_hint_msg: bool = False,       # æ˜¯å¦æ‰“å°æç¤ºæ¶ˆæ¯
    max_iters: int = 10,                # æœ€å¤§å¾ªç¯æ¬¡æ•°
) -> None:
    """åˆå§‹åŒ– ReActAgent

    è®¾è®¡è¦ç‚¹:
    1. æ‰€æœ‰å¤æ‚åŠŸèƒ½éƒ½æ˜¯å¯é€‰çš„ (çŸ¥è¯†åº“ã€è®¡åˆ’ã€é•¿æœŸè®°å¿†ç­‰)
    2. ä½¿ç”¨ä¾èµ–æ³¨å…¥ (ä¼ å…¥ modelã€formatter ç­‰)
    3. æä¾›åˆç†çš„é»˜è®¤å€¼ (max_iters=10)
    """
```

**å‚æ•°è¯¦è§£**:

1. **name** - Agent åç§°
   - ç”¨é€”: æ ‡è¯† Agentã€æ—¥å¿—ã€æ¶ˆæ¯å‘é€è€…
   - ç¤ºä¾‹: `"assistant"`, `"researcher"`, `"code_expert"`

2. **sys_prompt** - ç³»ç»Ÿæç¤º
   - ç”¨é€”: å®šä¹‰ Agent çš„è§’è‰²å’Œè¡Œä¸ºè§„èŒƒ
   - ç¤ºä¾‹:
     ```python
     sys_prompt = """ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ Python ç¼–ç¨‹åŠ©æ‰‹ã€‚

     ä½ çš„èŒè´£:
     1. å¸®åŠ©ç”¨æˆ·ç¼–å†™ã€è°ƒè¯• Python ä»£ç 
     2. è§£é‡Šä»£ç çš„å·¥ä½œåŸç†
     3. æä¾›æœ€ä½³å®è·µå»ºè®®

     ä½ çš„ç‰¹ç‚¹:
     - ä¸“ä¸š: æä¾›å‡†ç¡®çš„æŠ€æœ¯ä¿¡æ¯
     - å‹å¥½: ä½¿ç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€
     - é«˜æ•ˆ: å¿«é€Ÿå®šä½é—®é¢˜
     """
     ```

3. **model** - LLM æ¨¡å‹
   ```python
   # OpenAI
   model = OpenAIChatModel(
       model_name="gpt-4",
       api_key="your_key"
   )

   # Anthropic Claude
   model = AnthropicChatModel(
       model_name="claude-3-opus-20240229",
       api_key="your_key"
   )

   # é˜¿é‡Œäº‘é€šä¹‰åƒé—®
   model = DashScopeChatModel(
       model_name="qwen-max",
       api_key="your_key"
   )
   ```

4. **formatter** - æ¶ˆæ¯æ ¼å¼åŒ–å™¨
   ```python
   # å¿…é¡»ä¸ model åŒ¹é…
   formatter = OpenAIChatFormatter()  # é…åˆ OpenAI
   formatter = AnthropicChatFormatter()  # é…åˆ Anthropic
   formatter = DashScopeChatFormatter()  # é…åˆ DashScope
   ```

5. **toolkit** - å·¥å…·åŒ…
   ```python
   toolkit = Toolkit()

   # æ³¨å†Œè‡ªå®šä¹‰å·¥å…·
   toolkit.register_tool_function(my_tool)

   # æ³¨å†Œ MCP å·¥å…·
   await toolkit.register_mcp_client(mcp_client)
   ```

6. **memory** - çŸ­æœŸè®°å¿†
   ```python
   # é»˜è®¤: InMemoryMemory
   memory = InMemoryMemory()

   # è‡ªå®šä¹‰è®°å¿†
   memory = RedisMemory(redis_url="...")
   ```

7. **long_term_memory** - é•¿æœŸè®°å¿†
   ```python
   ltm = Mem0LongTermMemory(
       api_key="your_mem0_key",
       org_id="your_org",
       project_id="your_project"
   )
   ```

8. **long_term_memory_mode** - é•¿æœŸè®°å¿†æ¨¡å¼
   - `"agent_control"`: Agent é€šè¿‡å·¥å…·ä¸»åŠ¨è°ƒç”¨
   - `"static_control"`: æ¯æ¬¡ reply è‡ªåŠ¨æ£€ç´¢å’Œè®°å½•
   - `"both"`: ä¸¤è€…ç»“åˆ

9. **knowledge** - çŸ¥è¯†åº“
   ```python
   # å•ä¸ªçŸ¥è¯†åº“
   kb = SimpleKnowledgeBase(...)
   knowledge = kb

   # å¤šä¸ªçŸ¥è¯†åº“
   knowledge = [kb_python, kb_javascript, kb_general]
   ```

10. **max_iters** - æœ€å¤§å¾ªç¯æ¬¡æ•°
    - é˜²æ­¢æ— é™å¾ªç¯
    - ç®€å•ä»»åŠ¡: 5-10
    - å¤æ‚ä»»åŠ¡: 10-20

#### 3.3.3 ReAct å¾ªç¯æ ¸å¿ƒå®ç°

**reply() æ–¹æ³•å…¨æµç¨‹**:

```python
async def reply(
    self,
    msg: Msg | list[Msg] | None = None,
    structured_model: Type[BaseModel] | None = None
) -> Msg:
    """ReActAgent çš„æ ¸å¿ƒé€»è¾‘

    æ‰§è¡Œæµç¨‹:
    1. é¢„å¤„ç†: æ·»åŠ æ¶ˆæ¯åˆ°è®°å¿†
    2. å¢å¼º: é•¿æœŸè®°å¿†æ£€ç´¢ã€çŸ¥è¯†åº“æ£€ç´¢ã€è®¡åˆ’æç¤º
    3. ReAct å¾ªç¯: æ¨ç† â†’ æ‰§è¡Œ â†’ è§‚å¯Ÿ â†’ æ¨ç† â†’ ...
    4. åå¤„ç†: è®°å½•åˆ°é•¿æœŸè®°å¿†
    """

    # ========== 1. é¢„å¤„ç† ==========

    # å°†è¾“å…¥æ·»åŠ åˆ°è®°å¿†
    if msg is not None:
        await self.memory.add(msg)

    # æå–æŸ¥è¯¢æ–‡æœ¬ (ç”¨äºæ£€ç´¢)
    query_text = ""
    if msg:
        if isinstance(msg, list):
            query_text = msg[-1].get_text_content() if msg else ""
        else:
            query_text = msg.get_text_content() or ""

    # ========== 2. å¢å¼º ==========

    # 2.1 é•¿æœŸè®°å¿†æ£€ç´¢ (static_control æ¨¡å¼)
    if self._static_control and self.long_term_memory:
        retrieved = await self.long_term_memory.retrieve(
            query=query_text,
            agent_id=self.agent_id,
            limit=5
        )

        if retrieved:
            hint_msg = Msg(
                name="system",
                content=f"ç›¸å…³å†å²ä¿¡æ¯:\n{retrieved}",
                role="system"
            )
            await self.memory.add(hint_msg)

            if self.print_hint_msg:
                await self.print(hint_msg)

    # 2.2 çŸ¥è¯†åº“æ£€ç´¢
    if self.knowledge:
        # æŸ¥è¯¢é‡å†™ (å¯é€‰)
        if self.enable_rewrite_query:
            rewrite_prompt = f"""è¯·å°†ä»¥ä¸‹ç”¨æˆ·æŸ¥è¯¢é‡å†™ä¸ºæ›´é€‚åˆæ£€ç´¢çš„å½¢å¼:

            åŸå§‹æŸ¥è¯¢: {query_text}

            è¦æ±‚:
            - æå–å…³é”®è¯
            - è½¬æ¢ä¸ºé™ˆè¿°å¥
            - ä¿æŒè¯­ä¹‰ä¸å˜
            """

            rewrite_response = await self.model([
                Msg("system", rewrite_prompt, "system")
            ], structured_model=_QueryRewriteModel)

            query_text = rewrite_response.rewritten_query

        # ä»æ¯ä¸ªçŸ¥è¯†åº“æ£€ç´¢
        all_docs = []
        for kb in (self.knowledge if isinstance(self.knowledge, list) else [self.knowledge]):
            docs = await kb.retrieve(
                query=query_text,
                limit=3,
                score_threshold=0.7
            )
            all_docs.extend(docs)

        # æ·»åŠ åˆ°è®°å¿†
        if all_docs:
            docs_text = "\n\n".join([
                f"æ–‡æ¡£ {i+1} (ç›¸ä¼¼åº¦: {doc.score:.2f}):\n{doc.metadata.content['text']}"
                for i, doc in enumerate(all_docs)
            ])

            hint_msg = Msg(
                name="system",
                content=f"ç›¸å…³çŸ¥è¯†åº“ä¿¡æ¯:\n{docs_text}",
                role="system"
            )
            await self.memory.add(hint_msg)

            if self.print_hint_msg:
                await self.print(hint_msg)

    # ========== 3. ReAct å¾ªç¯ ==========

    reply_msg = None

    for iteration in range(self.max_iters):
        logger.debug(f"ReAct iteration {iteration + 1}/{self.max_iters}")

        # 3.1 æ¨ç†é˜¶æ®µ
        msg_reasoning = await self._reasoning(structured_model)

        # 3.2 æ£€æŸ¥æ˜¯å¦è°ƒç”¨å·¥å…·
        tool_calls = msg_reasoning.get_content_blocks("tool_use")

        if tool_calls:
            # 3.3 æ‰§è¡Œé˜¶æ®µ
            tool_results = await self._acting(tool_calls)

            # 3.4 æ·»åŠ ç»“æœåˆ°è®°å¿†
            await self.memory.add(tool_results)
        else:
            # æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œè¯´æ˜æ˜¯æœ€ç»ˆå›å¤
            reply_msg = msg_reasoning
            break
    else:
        # è¾¾åˆ°æœ€å¤§å¾ªç¯æ¬¡æ•°
        logger.warning(f"Reached max iterations ({self.max_iters})")
        reply_msg = msg_reasoning

    # ========== 4. åå¤„ç† ==========

    # 4.1 è®°å½•åˆ°é•¿æœŸè®°å¿† (static_control æ¨¡å¼)
    if self._static_control and self.long_term_memory:
        messages_to_record = []
        if msg:
            messages_to_record.append(msg if not isinstance(msg, list) else msg[-1])
        messages_to_record.append(reply_msg)

        await self.long_term_memory.record(
            messages=messages_to_record,
            agent_id=self.agent_id
        )

    return reply_msg
```

**æ¨ç†é˜¶æ®µ (_reasoning)**:

```python
async def _reasoning(
    self,
    structured_model: Type[BaseModel] | None = None
) -> Msg:
    """æ¨ç†é˜¶æ®µ: è°ƒç”¨ LLM ç”Ÿæˆæ€è€ƒå’Œè¡ŒåŠ¨

    æ‰§è¡Œæµç¨‹:
    1. è·å–è®¡åˆ’æç¤º (å¦‚æœæœ‰)
    2. è·å–è®°å¿†
    3. æ·»åŠ ç³»ç»Ÿæç¤º
    4. æ ¼å¼åŒ–æ¶ˆæ¯
    5. è°ƒç”¨æ¨¡å‹
    6. å¤„ç†å“åº” (æµå¼æˆ–éæµå¼)
    """

    # æ‰§è¡Œ pre_reasoning é’©å­
    kwargs = {}
    kwargs = await self._execute_hooks("pre_reasoning", kwargs)

    # 1. è·å–è®°å¿†
    memory = await self.memory.get_memory()

    # 2. æ·»åŠ ç³»ç»Ÿæç¤º
    if self.sys_prompt:
        memory = [
            Msg("system", self.sys_prompt, "system"),
            *memory
        ]

    # 3. è·å–è®¡åˆ’æç¤º
    if self.plan_notebook:
        plan_hint = await self.plan_notebook.get_current_hint()
        if plan_hint:
            memory.append(plan_hint)

            if self.print_hint_msg:
                await self.print(plan_hint)

    # 4. æ ¼å¼åŒ–æ¶ˆæ¯
    formatted_msgs = await self.formatter.format(
        msgs=memory,
        tools=self.toolkit.json_schemas
    )

    # 5. è°ƒç”¨æ¨¡å‹
    model_response = await self.model(
        messages=formatted_msgs,
        tools=self.toolkit.json_schemas,
        structured_model=structured_model
    )

    # 6. å¤„ç†å“åº”
    if isinstance(model_response, AsyncGenerator):
        # æµå¼å“åº”
        msg_reasoning = None
        async for chunk in model_response:
            # æ‰“å°æµå¼å—
            await self.print(chunk, last=chunk.is_last)

            if chunk.is_last:
                msg_reasoning = chunk.to_msg(self.name)

        if msg_reasoning is None:
            raise RuntimeError("No response from streaming model")
    else:
        # éæµå¼å“åº”
        msg_reasoning = model_response.to_msg(self.name)
        await self.print(msg_reasoning)

    # æ·»åŠ åˆ°è®°å¿†
    await self.memory.add(msg_reasoning)

    # æ‰§è¡Œ post_reasoning é’©å­
    await self._execute_hooks("post_reasoning", {"output": msg_reasoning})

    return msg_reasoning
```

**æ‰§è¡Œé˜¶æ®µ (_acting)**:

```python
async def _acting(
    self,
    tool_calls: list[ToolUseBlock]
) -> list[Msg]:
    """æ‰§è¡Œé˜¶æ®µ: è°ƒç”¨å·¥å…·å¹¶è·å–ç»“æœ

    æ‰§è¡Œæµç¨‹:
    1. æ‰§è¡Œ pre_acting é’©å­
    2. å¹¶è¡Œ/é¡ºåºæ‰§è¡Œå·¥å…·
    3. æ”¶é›†ç»“æœ
    4. æ„é€ å·¥å…·ç»“æœæ¶ˆæ¯
    5. æ‰§è¡Œ post_acting é’©å­
    """

    # æ‰§è¡Œ pre_acting é’©å­
    kwargs = {"tool_calls": tool_calls}
    kwargs = await self._execute_hooks("pre_acting", kwargs)
    tool_calls = kwargs["tool_calls"]

    # æ‰§è¡Œå·¥å…·
    if self.parallel_tool_calls:
        # å¹¶è¡Œæ‰§è¡Œ
        tool_responses = await asyncio.gather(*[
            self._call_single_tool(tc)
            for tc in tool_calls
        ])
    else:
        # é¡ºåºæ‰§è¡Œ
        tool_responses = []
        for tc in tool_calls:
            response = await self._call_single_tool(tc)
            tool_responses.append(response)

    # æ„é€ å·¥å…·ç»“æœæ¶ˆæ¯
    tool_result_msgs = []
    for tc, tr in zip(tool_calls, tool_responses):
        msg = Msg(
            name=self.name,
            content=[
                ToolResultBlock(
                    type="tool_result",
                    id=tc["id"],
                    output=tr.content
                )
            ],
            role="assistant"
        )
        tool_result_msgs.append(msg)

    # æ‰§è¡Œ post_acting é’©å­
    await self._execute_hooks("post_acting", {"tool_results": tool_result_msgs})

    return tool_result_msgs

async def _call_single_tool(self, tool_call: ToolUseBlock) -> ToolResponse:
    """è°ƒç”¨å•ä¸ªå·¥å…· (æ”¯æŒæµå¼)"""
    final_response = None

    async for response in self.toolkit.call_tool_function(tool_call):
        if response.stream:
            # æµå¼å·¥å…·: æ‰“å°æ¯ä¸€å—
            await self.print(
                Msg(self.name, response.content, "assistant"),
                last=response.is_last
            )

        if response.is_last:
            final_response = response

    return final_response
```

#### 3.3.4 ç‰¹æ®ŠåŠŸèƒ½

**1. ç»“æ„åŒ–è¾“å‡º**

```python
from pydantic import BaseModel, Field

class AnalysisResult(BaseModel):
    """åˆ†æç»“æœçš„ç»“æ„åŒ–æ¨¡å‹"""
    sentiment: str = Field(description="æƒ…æ„Ÿå€¾å‘: positive/negative/neutral")
    topics: list[str] = Field(description="ä¸»è¦è¯é¢˜åˆ—è¡¨")
    confidence: float = Field(description="ç½®ä¿¡åº¦ 0-1")

# ä½¿ç”¨ç»“æ„åŒ–è¾“å‡º
response = await agent(
    Msg("user", "åˆ†æè¿™ç¯‡æ–‡ç« ", "user"),
    structured_model=AnalysisResult
)

# response ä¼šå¼ºåˆ¶ç¬¦åˆ AnalysisResult ç»“æ„
```

**2. å®Œæˆå‡½æ•° (Finish Function)**

ReActAgent è‡ªåŠ¨æ³¨å†Œä¸€ä¸ª `generate_response` å‡½æ•°ï¼Œç”¨äºç»“æŸå¾ªç¯:

```python
def generate_response(self, response: str) -> ToolResponse:
    """ç”Ÿæˆæœ€ç»ˆå›å¤

    Args:
        response: è¦è¿”å›ç»™ç”¨æˆ·çš„å›å¤å†…å®¹

    è¿”å›:
        ToolResponse åŒ…å«å›å¤æ–‡æœ¬
    """
    return ToolResponse(
        content=[TextBlock(type="text", text=response)]
    )
```

LLM ä¼šè¿™æ ·è°ƒç”¨:
```json
{
  "type": "tool_use",
  "name": "generate_response",
  "input": {
    "response": "ä»Šå¤©åŒ—äº¬å¤©æ°”æ™´æœ—ï¼Œæ¸©åº¦15åº¦"
  }
}
```

**3. å…ƒå·¥å…· (Meta Tool)**

å¦‚æœ `enable_meta_tool=True`ï¼Œä¼šæ³¨å†Œ `reset_equipped_tools` å‡½æ•°:

```python
def reset_equipped_tools(self, group_names: list[str]) -> ToolResponse:
    """è®© Agent åŠ¨æ€é€‰æ‹©å·¥å…·ç»„

    Args:
        group_names: è¦æ¿€æ´»çš„å·¥å…·ç»„åç§°åˆ—è¡¨

    ç¤ºä¾‹:
        Agent åœ¨å¤„ç†æ–‡ä»¶ä»»åŠ¡æ—¶:
        reset_equipped_tools(["file", "text_processing"])

        Agent åœ¨å¤„ç†ç½‘ç»œä»»åŠ¡æ—¶:
        reset_equipped_tools(["web", "api"])
    """
    return self.toolkit.reset_equipped_tools(group_names)
```

---

### 3.4 UserAgent å®ç°

**æ–‡ä»¶ä½ç½®**: `src/agentscope/agent/_user_agent.py`

#### 3.4.1 UserAgent è®¾è®¡

**ç”¨é€”**: ä¸äººç±»ç”¨æˆ·äº¤äº’ï¼Œè·å–ç”¨æˆ·è¾“å…¥ã€‚

**è®¾è®¡ç†å¿µ**:
1. **è¾“å…¥æºå¯é…ç½®**: ç»ˆç«¯ã€Web UIã€Studio ç­‰
2. **æ— çŠ¶æ€**: ä¸éœ€è¦è®°å¿†ã€æ¨¡å‹ç­‰
3. **ç®€å•ç›´æ¥**: åªåšä¸€ä»¶äº‹â€”è·å–ç”¨æˆ·è¾“å…¥

#### 3.4.2 è¾“å…¥æ–¹æ³•

**æ”¯æŒçš„è¾“å…¥æº**:

1. **ç»ˆç«¯è¾“å…¥** (é»˜è®¤)
   ```python
   user = UserAgent(name="user")
   response = await user()
   # æç¤ºç”¨æˆ·åœ¨ç»ˆç«¯è¾“å…¥
   ```

2. **Studio è¾“å…¥**
   ```python
   from agentscope.agent import StudioUserInput

   # ä¸ºæ‰€æœ‰ UserAgent è®¾ç½® Studio è¾“å…¥
   UserAgent.override_class_input_method(
       StudioUserInput(studio_url="http://localhost:5000")
   )

   user = UserAgent(name="user")
   response = await user()
   # ä» Studio Web ç•Œé¢è·å–è¾“å…¥
   ```

3. **è‡ªå®šä¹‰è¾“å…¥**
   ```python
   def custom_input_method(agent_name: str) -> str:
       """è‡ªå®šä¹‰è¾“å…¥æ–¹æ³•"""
       # å¯ä»¥ä»ä»»ä½•æ¥æºè·å–è¾“å…¥
       return get_input_from_custom_source()

   user = UserAgent(name="user")
   user.override_instance_input_method(custom_input_method)
   ```

#### 3.4.3 å®Œæ•´ç¤ºä¾‹

```python
# åœºæ™¯: ç”¨æˆ·ä¸ AI åŠ©æ‰‹å¯¹è¯

user_agent = UserAgent(name="user")
ai_agent = ReActAgent(
    name="assistant",
    sys_prompt="You are a helpful assistant",
    model=model,
    formatter=formatter
)

# å¯¹è¯å¾ªç¯
while True:
    # è·å–ç”¨æˆ·è¾“å…¥
    user_msg = await user_agent()

    # æ£€æŸ¥é€€å‡º
    if user_msg.get_text_content().lower() in ["quit", "exit", "bye"]:
        break

    # AI å›å¤
    ai_response = await ai_agent(user_msg)

    # ç»§ç»­ä¸‹ä¸€è½®
```

---

## ç¬¬å››ç« : Model æ¨¡å—è¯¦ç»†åˆ†æ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/model/`

### 4.1 ChatModelBase åŸºç±»

**æ–‡ä»¶**: `_model_base.py`

#### 4.1.1 è®¾è®¡ç†å¿µ

ChatModelBase æ˜¯æ‰€æœ‰èŠå¤©æ¨¡å‹çš„æŠ½è±¡åŸºç±»ï¼Œå®šä¹‰äº†ç»Ÿä¸€çš„æ¥å£ã€‚

**æ ¸å¿ƒè®¾è®¡åŸåˆ™**:
1. **æ¨¡å‹æ— å…³**: ä¸ç»‘å®šç‰¹å®šå‚å•†çš„ API
2. **ç»Ÿä¸€æ¥å£**: æ‰€æœ‰æ¨¡å‹ä½¿ç”¨ç›¸åŒçš„è°ƒç”¨æ–¹å¼
3. **å¼‚æ­¥ä¼˜å…ˆ**: æ”¯æŒå¼‚æ­¥è°ƒç”¨
4. **æµå¼æ”¯æŒ**: æ”¯æŒæµå¼å’Œéæµå¼è¾“å‡º
5. **å·¥å…·è°ƒç”¨**: åŸç”Ÿæ”¯æŒå·¥å…·è°ƒç”¨ï¼ˆFunction Callingï¼‰

#### 4.1.2 æ ¸å¿ƒæ–¹æ³•

```python
from abc import ABC, abstractmethod
from typing import AsyncGenerator

class ChatModelBase(ABC):
    """èŠå¤©æ¨¡å‹åŸºç±»"""

    def __init__(
        self,
        model_name: str,
        api_key: str | None = None,
        api_base: str | None = None,
        **kwargs
    ):
        """åˆå§‹åŒ–æ¨¡å‹

        Args:
            model_name: æ¨¡å‹åç§°
            api_key: API å¯†é’¥
            api_base: API åŸºç¡€ URL
        """
        self.model_name = model_name
        self.api_key = api_key
        self.api_base = api_base

    @abstractmethod
    async def __call__(
        self,
        messages: list[dict],
        tools: list[dict] | None = None,
        stream: bool = False,
        **kwargs
    ) -> ChatResponse | AsyncGenerator[ChatResponse, None]:
        """è°ƒç”¨æ¨¡å‹ç”Ÿæˆå›å¤

        Args:
            messages: æ¶ˆæ¯åˆ—è¡¨ï¼ˆå·²æ ¼å¼åŒ–ï¼‰
            tools: å·¥å…·åˆ—è¡¨ï¼ˆJSON Schema æ ¼å¼ï¼‰
            stream: æ˜¯å¦ä½¿ç”¨æµå¼è¾“å‡º
            **kwargs: å…¶ä»–æ¨¡å‹å‚æ•°ï¼ˆtemperatureã€max_tokens ç­‰ï¼‰

        Returns:
            ChatResponse æˆ– AsyncGenerator[ChatResponse]
        """
        raise NotImplementedError
```

### 4.2 å“åº”å¯¹è±¡è®¾è®¡

**æ–‡ä»¶**: `_model_response.py`

#### 4.2.1 ChatResponse ç±»

```python
from dataclasses import dataclass
from agentscope.message import ContentBlock

@dataclass
class ChatResponse:
    """èŠå¤©æ¨¡å‹å“åº”å¯¹è±¡

    å±æ€§:
        id: å“åº” ID
        content: å†…å®¹å—åˆ—è¡¨
        created_at: åˆ›å»ºæ—¶é—´
        type: å“åº”ç±»å‹ï¼ˆ"chat"ï¼‰
        stream: æ˜¯å¦ä¸ºæµå¼å“åº”
        is_last: æ˜¯å¦ä¸ºæµå¼å“åº”çš„æœ€åä¸€å—
        usage: Token ä½¿ç”¨æƒ…å†µ
        metadata: å…ƒæ•°æ®
    """
    id: str
    content: list[ContentBlock]
    created_at: str
    type: str = "chat"
    stream: bool = False
    is_last: bool = True
    usage: dict | None = None
    metadata: dict | None = None

    def to_msg(self, name: str) -> Msg:
        """è½¬æ¢ä¸º Msg å¯¹è±¡

        Args:
            name: æ¶ˆæ¯å‘é€è€…åç§°

        Returns:
            Msg å¯¹è±¡
        """
        return Msg(
            name=name,
            content=self.content,
            role="assistant",
            metadata={
                "response_id": self.id,
                "usage": self.usage,
                **(self.metadata or {})
            }
        )

    def get_text_content(self) -> str:
        """æå–æ–‡æœ¬å†…å®¹"""
        text_parts = []
        for block in self.content:
            if block["type"] == "text":
                text_parts.append(block["text"])
            elif block["type"] == "thinking":
                # æ€è€ƒå—ä¹Ÿæ˜¯æ–‡æœ¬
                text_parts.append(block["thinking"])
        return "".join(text_parts)
```

### 4.3 å„å‚å•†æ¨¡å‹å®ç°

#### 4.3.1 DashScope æ¨¡å‹ï¼ˆé˜¿é‡Œäº‘é€šä¹‰åƒé—®ï¼‰

**æ–‡ä»¶**: `_dashscope_model.py`

```python
from dashscope import Generation
import dashscope

class DashScopeChatModel(ChatModelBase):
    """é˜¿é‡Œäº‘é€šä¹‰åƒé—®æ¨¡å‹

    æ”¯æŒçš„æ¨¡å‹:
    - qwen-max: æœ€å¼ºå¤§çš„é€šä¹‰åƒé—®æ¨¡å‹
    - qwen-plus: å¹³è¡¡æ€§èƒ½å’Œæˆæœ¬
    - qwen-turbo: å¿«é€Ÿå“åº”
    """

    def __init__(
        self,
        model_name: str = "qwen-max",
        api_key: str | None = None,
        stream: bool = False,
        **kwargs
    ):
        """åˆå§‹åŒ– DashScope æ¨¡å‹

        Args:
            model_name: æ¨¡å‹åç§°
            api_key: DashScope API Key
            stream: æ˜¯å¦é»˜è®¤ä½¿ç”¨æµå¼è¾“å‡º
        """
        super().__init__(model_name, api_key)

        # è®¾ç½® API Key
        if api_key:
            dashscope.api_key = api_key

        self.stream = stream

    async def __call__(
        self,
        messages: list[dict],
        tools: list[dict] | None = None,
        stream: bool | None = None,
        **kwargs
    ) -> ChatResponse | AsyncGenerator[ChatResponse, None]:
        """è°ƒç”¨ DashScope API"""

        # å‡†å¤‡è¯·æ±‚å‚æ•°
        params = {
            "model": self.model_name,
            "messages": messages,
            **kwargs
        }

        # æ·»åŠ å·¥å…·
        if tools:
            params["tools"] = tools

        # æ˜¯å¦æµå¼
        use_stream = stream if stream is not None else self.stream

        if use_stream:
            # æµå¼è°ƒç”¨
            return self._stream_call(params)
        else:
            # éæµå¼è°ƒç”¨
            return await self._non_stream_call(params)

    async def _non_stream_call(self, params: dict) -> ChatResponse:
        """éæµå¼è°ƒç”¨"""
        response = await Generation.call(**params)

        # æå–å†…å®¹
        content_blocks = self._parse_response(response)

        # æ„é€  ChatResponse
        return ChatResponse(
            id=response.request_id,
            content=content_blocks,
            created_at=datetime.now().isoformat(),
            usage={
                "prompt_tokens": response.usage.input_tokens,
                "completion_tokens": response.usage.output_tokens,
                "total_tokens": response.usage.total_tokens
            }
        )

    async def _stream_call(
        self,
        params: dict
    ) -> AsyncGenerator[ChatResponse, None]:
        """æµå¼è°ƒç”¨"""
        responses = Generation.call(stream=True, **params)

        accumulated_content = []

        for chunk in responses:
            if chunk.status_code == 200:
                # è§£æå—
                content_blocks = self._parse_response(chunk)

                # ç´¯ç§¯å†…å®¹
                accumulated_content.extend(content_blocks)

                # åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€å—
                is_last = chunk.output.finish_reason is not None

                yield ChatResponse(
                    id=chunk.request_id,
                    content=accumulated_content.copy(),
                    created_at=datetime.now().isoformat(),
                    stream=True,
                    is_last=is_last,
                    usage={
                        "prompt_tokens": chunk.usage.input_tokens,
                        "completion_tokens": chunk.usage.output_tokens,
                        "total_tokens": chunk.usage.total_tokens
                    } if is_last else None
                )

    def _parse_response(self, response) -> list[ContentBlock]:
        """è§£æ DashScope å“åº”ä¸ºå†…å®¹å—"""
        content_blocks = []

        # è§£ææ–‡æœ¬å†…å®¹
        if hasattr(response.output, "text"):
            content_blocks.append(
                TextBlock(type="text", text=response.output.text)
            )

        # è§£æå·¥å…·è°ƒç”¨
        if hasattr(response.output, "tool_calls"):
            for tool_call in response.output.tool_calls:
                content_blocks.append(
                    ToolUseBlock(
                        type="tool_use",
                        id=tool_call.id,
                        name=tool_call.function.name,
                        input=json.loads(tool_call.function.arguments)
                    )
                )

        return content_blocks
```

**ä½¿ç”¨ç¤ºä¾‹**:
```python
# åˆ›å»ºæ¨¡å‹
model = DashScopeChatModel(
    model_name="qwen-max",
    api_key="your_api_key",
    stream=True  # å¯ç”¨æµå¼è¾“å‡º
)

# éæµå¼è°ƒç”¨
messages = [
    {"role": "user", "content": "ä½ å¥½"}
]
response = await model(messages)
print(response.get_text_content())

# æµå¼è°ƒç”¨
async for chunk in model(messages, stream=True):
    print(chunk.get_text_content(), end="", flush=True)
    if chunk.is_last:
        print(f"\nä½¿ç”¨ Tokens: {chunk.usage['total_tokens']}")
```

#### 4.3.2 OpenAI æ¨¡å‹

**æ–‡ä»¶**: `_openai_model.py`

```python
from openai import AsyncOpenAI

class OpenAIChatModel(ChatModelBase):
    """OpenAI GPT æ¨¡å‹

    æ”¯æŒçš„æ¨¡å‹:
    - gpt-4-turbo: GPT-4 Turbo
    - gpt-4: GPT-4
    - gpt-3.5-turbo: GPT-3.5 Turbo
    """

    def __init__(
        self,
        model_name: str = "gpt-4-turbo",
        api_key: str | None = None,
        api_base: str | None = None,
        **kwargs
    ):
        super().__init__(model_name, api_key, api_base)

        # åˆ›å»ºå¼‚æ­¥å®¢æˆ·ç«¯
        self.client = AsyncOpenAI(
            api_key=api_key,
            base_url=api_base
        )

    async def __call__(
        self,
        messages: list[dict],
        tools: list[dict] | None = None,
        stream: bool = False,
        **kwargs
    ) -> ChatResponse | AsyncGenerator[ChatResponse, None]:
        """è°ƒç”¨ OpenAI API"""

        # å‡†å¤‡å‚æ•°
        params = {
            "model": self.model_name,
            "messages": messages,
            "stream": stream,
            **kwargs
        }

        # æ·»åŠ å·¥å…·
        if tools:
            params["tools"] = [
                {"type": "function", "function": tool}
                for tool in tools
            ]

        if stream:
            return self._stream_call(params)
        else:
            return await self._non_stream_call(params)

    async def _non_stream_call(self, params: dict) -> ChatResponse:
        """éæµå¼è°ƒç”¨"""
        response = await self.client.chat.completions.create(**params)

        # è§£æå†…å®¹
        content_blocks = self._parse_choice(response.choices[0])

        return ChatResponse(
            id=response.id,
            content=content_blocks,
            created_at=datetime.fromtimestamp(response.created).isoformat(),
            usage={
                "prompt_tokens": response.usage.prompt_tokens,
                "completion_tokens": response.usage.completion_tokens,
                "total_tokens": response.usage.total_tokens
            }
        )

    async def _stream_call(
        self,
        params: dict
    ) -> AsyncGenerator[ChatResponse, None]:
        """æµå¼è°ƒç”¨"""
        stream = await self.client.chat.completions.create(**params)

        accumulated_content = []
        response_id = None

        async for chunk in stream:
            if not chunk.choices:
                continue

            delta = chunk.choices[0].delta

            # ä¿å­˜ response ID
            if response_id is None:
                response_id = chunk.id

            # è§£æå¢é‡å†…å®¹
            if delta.content:
                accumulated_content.append(
                    TextBlock(type="text", text=delta.content)
                )

            if delta.tool_calls:
                for tool_call in delta.tool_calls:
                    accumulated_content.append(
                        ToolUseBlock(
                            type="tool_use",
                            id=tool_call.id,
                            name=tool_call.function.name,
                            input=json.loads(tool_call.function.arguments)
                        )
                    )

            # åˆ¤æ–­æ˜¯å¦ç»“æŸ
            is_last = chunk.choices[0].finish_reason is not None

            yield ChatResponse(
                id=response_id,
                content=accumulated_content.copy(),
                created_at=datetime.fromtimestamp(chunk.created).isoformat(),
                stream=True,
                is_last=is_last
            )
```

#### 4.3.3 Anthropic Claude æ¨¡å‹

**æ–‡ä»¶**: `_anthropic_model.py`

```python
from anthropic import AsyncAnthropic

class AnthropicChatModel(ChatModelBase):
    """Anthropic Claude æ¨¡å‹

    æ”¯æŒçš„æ¨¡å‹:
    - claude-3-5-sonnet-20241022: Claude 3.5 Sonnet
    - claude-3-opus-20240229: Claude 3 Opus
    - claude-3-sonnet-20240229: Claude 3 Sonnet
    """

    def __init__(
        self,
        model_name: str = "claude-3-5-sonnet-20241022",
        api_key: str | None = None,
        **kwargs
    ):
        super().__init__(model_name, api_key)

        self.client = AsyncAnthropic(api_key=api_key)

    async def __call__(
        self,
        messages: list[dict],
        tools: list[dict] | None = None,
        stream: bool = False,
        system: str | None = None,
        **kwargs
    ) -> ChatResponse | AsyncGenerator[ChatResponse, None]:
        """è°ƒç”¨ Anthropic API

        Note: Anthropic çš„ system æ¶ˆæ¯éœ€è¦å•ç‹¬ä¼ é€’
        """

        params = {
            "model": self.model_name,
            "messages": messages,
            "stream": stream,
            "max_tokens": kwargs.pop("max_tokens", 4096),
            **kwargs
        }

        # æ·»åŠ  system æ¶ˆæ¯
        if system:
            params["system"] = system

        # æ·»åŠ å·¥å…·
        if tools:
            params["tools"] = tools

        if stream:
            return self._stream_call(params)
        else:
            return await self._non_stream_call(params)

    async def _non_stream_call(self, params: dict) -> ChatResponse:
        """éæµå¼è°ƒç”¨"""
        response = await self.client.messages.create(**params)

        # è§£æå†…å®¹å—
        content_blocks = []
        for block in response.content:
            if block.type == "text":
                content_blocks.append(
                    TextBlock(type="text", text=block.text)
                )
            elif block.type == "tool_use":
                content_blocks.append(
                    ToolUseBlock(
                        type="tool_use",
                        id=block.id,
                        name=block.name,
                        input=block.input
                    )
                )
            elif block.type == "thinking":
                # Claude æ”¯æŒæ€è€ƒå—
                content_blocks.append(
                    ThinkingBlock(
                        type="thinking",
                        thinking=block.thinking
                    )
                )

        return ChatResponse(
            id=response.id,
            content=content_blocks,
            created_at=datetime.now().isoformat(),
            usage={
                "prompt_tokens": response.usage.input_tokens,
                "completion_tokens": response.usage.output_tokens,
                "total_tokens": response.usage.input_tokens + response.usage.output_tokens
            },
            metadata={"stop_reason": response.stop_reason}
        )

    async def _stream_call(
        self,
        params: dict
    ) -> AsyncGenerator[ChatResponse, None]:
        """æµå¼è°ƒç”¨"""
        async with self.client.messages.stream(**params) as stream:
            accumulated_content = []
            response_id = None

            async for event in stream:
                # æ¶ˆæ¯å¼€å§‹äº‹ä»¶
                if event.type == "message_start":
                    response_id = event.message.id

                # å†…å®¹å—å¢é‡äº‹ä»¶
                elif event.type == "content_block_delta":
                    delta = event.delta

                    if delta.type == "text_delta":
                        accumulated_content.append(
                            TextBlock(type="text", text=delta.text)
                        )

                    elif delta.type == "input_json_delta":
                        # å·¥å…·è°ƒç”¨çš„å‚æ•°å¢é‡
                        pass  # ç´¯ç§¯å¤„ç†

                # æ¶ˆæ¯ç»“æŸäº‹ä»¶
                elif event.type == "message_delta":
                    is_last = True

                    yield ChatResponse(
                        id=response_id,
                        content=accumulated_content.copy(),
                        created_at=datetime.now().isoformat(),
                        stream=True,
                        is_last=is_last,
                        usage={
                            "prompt_tokens": event.usage.input_tokens,
                            "completion_tokens": event.usage.output_tokens,
                            "total_tokens": event.usage.input_tokens + event.usage.output_tokens
                        }
                    )
```

### 4.4 æµå¼å¤„ç†æœºåˆ¶

#### 4.4.1 æµå¼è¾“å‡ºçš„ä¼˜åŠ¿

1. **å³æ—¶åé¦ˆ**: ç”¨æˆ·å¯ä»¥ç«‹å³çœ‹åˆ°ç”Ÿæˆçš„å†…å®¹
2. **é™ä½å»¶è¿Ÿæ„Ÿ**: æ— éœ€ç­‰å¾…å®Œæ•´å“åº”
3. **æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ**: ç±»ä¼¼æ‰“å­—æ•ˆæœ

#### 4.4.2 æµå¼å¤„ç†å®ç°

```python
async def handle_stream_response(model, messages):
    """å¤„ç†æµå¼å“åº”çš„ç¤ºä¾‹"""

    print("Assistant: ", end="", flush=True)

    full_content = ""
    final_response = None

    async for chunk in model(messages, stream=True):
        # æå–æ–°å¢æ–‡æœ¬
        current_content = chunk.get_text_content()
        new_content = current_content[len(full_content):]

        # æ‰“å°æ–°å¢éƒ¨åˆ†
        print(new_content, end="", flush=True)

        # æ›´æ–°ç´¯ç§¯å†…å®¹
        full_content = current_content

        # ä¿å­˜æœ€ç»ˆå“åº”
        if chunk.is_last:
            final_response = chunk

    print()  # æ¢è¡Œ

    # è¿”å›å®Œæ•´å“åº”
    return final_response
```

#### 4.4.3 æµå¼å·¥å…·è°ƒç”¨

æŸäº›æ¨¡å‹ï¼ˆå¦‚ Anthropic Claudeï¼‰æ”¯æŒæµå¼å·¥å…·è°ƒç”¨ï¼š

```python
async def handle_stream_with_tools(model, messages, tools):
    """å¤„ç†å¸¦å·¥å…·çš„æµå¼å“åº”"""

    accumulated_tool_calls = []

    async for chunk in model(messages, tools=tools, stream=True):
        # æ£€æŸ¥å·¥å…·è°ƒç”¨
        tool_uses = chunk.content

        for block in tool_uses:
            if block["type"] == "tool_use":
                # æµå¼ç´¯ç§¯å·¥å…·è°ƒç”¨
                accumulated_tool_calls.append(block)

        # æœ€åä¸€å—æ—¶æ‰§è¡Œå·¥å…·
        if chunk.is_last:
            for tool_use in accumulated_tool_calls:
                result = await execute_tool(
                    tool_use["name"],
                    tool_use["input"]
                )
                print(f"å·¥å…· {tool_use['name']} æ‰§è¡Œç»“æœ: {result}")
```

---

## ç¬¬äº”ç« : Message ä¸é€šä¿¡æœºåˆ¶

**æ–‡ä»¶ä½ç½®**: `src/agentscope/message/`

### 5.1 Msg ç±»è®¾è®¡

**æ–‡ä»¶**: `_message_base.py`

#### 5.1.1 æ ¸å¿ƒç»“æ„

```python
from dataclasses import dataclass, field
from datetime import datetime
import shortuuid

@dataclass
class Msg:
    """æ¶ˆæ¯ç±»

    è®¾è®¡ç†å¿µ:
    1. ç»Ÿä¸€æ¶ˆæ¯æ ¼å¼
    2. æ”¯æŒå¤šæ¨¡æ€å†…å®¹
    3. å¯åºåˆ—åŒ–
    4. å…ƒæ•°æ®æ‰©å±•
    """

    name: str
    """å‘é€è€…åç§°ï¼ˆAgent åç§°æˆ– "user"ã€"system"ï¼‰"""

    content: str | list[ContentBlock]
    """æ¶ˆæ¯å†…å®¹ï¼šçº¯æ–‡æœ¬æˆ–å†…å®¹å—åˆ—è¡¨"""

    role: str
    """è§’è‰²ï¼šuser, assistant, system"""

    id: str = field(default_factory=lambda: shortuuid.uuid())
    """æ¶ˆæ¯å”¯ä¸€æ ‡è¯†"""

    metadata: dict | None = None
    """å…ƒæ•°æ®ï¼šå­˜å‚¨é¢å¤–ä¿¡æ¯"""

    timestamp: str = field(
        default_factory=lambda: datetime.now().isoformat()
    )
    """æ—¶é—´æˆ³"""

    invocation_id: str | None = None
    """è°ƒç”¨æ ‡è¯†ï¼šåŒä¸€æ¬¡ Agent è°ƒç”¨çš„æ¶ˆæ¯å…±äº«æ­¤ ID"""

    def __post_init__(self):
        """åˆå§‹åŒ–åå¤„ç†"""
        # å¦‚æœ content æ˜¯å­—ç¬¦ä¸²ï¼Œè½¬æ¢ä¸º TextBlock
        if isinstance(self.content, str):
            self.content = [TextBlock(type="text", text=self.content)]
```

#### 5.1.2 æ ¸å¿ƒæ–¹æ³•

```python
class Msg:
    # ... å±æ€§å®šä¹‰ ...

    def get_text_content(self) -> str:
        """æå–æ‰€æœ‰æ–‡æœ¬å†…å®¹

        Returns:
            æ‹¼æ¥åçš„æ–‡æœ¬å­—ç¬¦ä¸²
        """
        if isinstance(self.content, str):
            return self.content

        text_parts = []
        for block in self.content:
            if block["type"] == "text":
                text_parts.append(block["text"])
            elif block["type"] == "thinking":
                text_parts.append(block["thinking"])

        return "".join(text_parts)

    def get_content_blocks(
        self,
        block_type: str | None = None
    ) -> list[ContentBlock]:
        """è·å–å†…å®¹å—

        Args:
            block_type: å—ç±»å‹è¿‡æ»¤ï¼ˆå¦‚ "tool_use"ã€"image" ç­‰ï¼‰
                      å¦‚æœä¸º Noneï¼Œè¿”å›æ‰€æœ‰å—

        Returns:
            å†…å®¹å—åˆ—è¡¨
        """
        if isinstance(self.content, str):
            return [TextBlock(type="text", text=self.content)]

        if block_type is None:
            return self.content

        return [
            block for block in self.content
            if block.get("type") == block_type
        ]

    def to_dict(self) -> dict:
        """åºåˆ—åŒ–ä¸ºå­—å…¸

        Returns:
            å­—å…¸è¡¨ç¤º
        """
        return {
            "id": self.id,
            "name": self.name,
            "content": self._serialize_content(),
            "role": self.role,
            "metadata": self.metadata,
            "timestamp": self.timestamp,
            "invocation_id": self.invocation_id
        }

    def _serialize_content(self) -> list[dict]:
        """åºåˆ—åŒ–å†…å®¹"""
        if isinstance(self.content, str):
            return [{"type": "text", "text": self.content}]

        return [
            self._serialize_block(block)
            for block in self.content
        ]

    def _serialize_block(self, block: ContentBlock) -> dict:
        """åºåˆ—åŒ–å•ä¸ªå†…å®¹å—"""
        # ç›´æ¥è¿”å›å­—å…¸è¡¨ç¤º
        if isinstance(block, dict):
            return block

        # å¦‚æœæ˜¯å¯¹è±¡ï¼Œè°ƒç”¨å…¶åºåˆ—åŒ–æ–¹æ³•
        if hasattr(block, "to_dict"):
            return block.to_dict()

        # å¦åˆ™è½¬æ¢ä¸ºå­—å…¸
        return dict(block)

    @classmethod
    def from_dict(cls, data: dict) -> "Msg":
        """ä»å­—å…¸ååºåˆ—åŒ–

        Args:
            data: å­—å…¸æ•°æ®

        Returns:
            Msg å¯¹è±¡
        """
        # ååºåˆ—åŒ–å†…å®¹å—
        content = [
            cls._deserialize_block(block)
            for block in data["content"]
        ]

        return cls(
            id=data["id"],
            name=data["name"],
            content=content,
            role=data["role"],
            metadata=data.get("metadata"),
            timestamp=data["timestamp"],
            invocation_id=data.get("invocation_id")
        )

    @classmethod
    def _deserialize_block(cls, block_dict: dict) -> ContentBlock:
        """ååºåˆ—åŒ–å†…å®¹å—"""
        block_type = block_dict["type"]

        # æ ¹æ®ç±»å‹åˆ›å»ºå¯¹åº”çš„å—å¯¹è±¡
        if block_type == "text":
            return TextBlock(**block_dict)
        elif block_type == "image":
            return ImageBlock(**block_dict)
        elif block_type == "audio":
            return AudioBlock(**block_dict)
        elif block_type == "video":
            return VideoBlock(**block_dict)
        elif block_type == "tool_use":
            return ToolUseBlock(**block_dict)
        elif block_type == "tool_result":
            return ToolResultBlock(**block_dict)
        elif block_type == "thinking":
            return ThinkingBlock(**block_dict)
        else:
            # æœªçŸ¥ç±»å‹ï¼Œè¿”å›åŸå§‹å­—å…¸
            return block_dict
```

### 5.2 å†…å®¹å—ç³»ç»Ÿ

**æ–‡ä»¶**: `_message_block.py`

#### 5.2.1 TextBlock - æ–‡æœ¬å—

```python
from typing import TypedDict

class TextBlock(TypedDict):
    """æ–‡æœ¬å†…å®¹å—

    æœ€åŸºç¡€çš„å†…å®¹ç±»å‹
    """
    type: str  # "text"
    text: str  # æ–‡æœ¬å†…å®¹

# ä½¿ç”¨ç¤ºä¾‹
text_block = TextBlock(
    type="text",
    text="Hello, world!"
)
```

#### 5.2.2 ImageBlock - å›¾ç‰‡å—

```python
class ImageSource(TypedDict):
    """å›¾ç‰‡æ¥æº"""
    type: str  # "url" æˆ– "base64"

class URLSource(ImageSource):
    """URL å›¾ç‰‡æº"""
    type: str  # "url"
    url: str   # å›¾ç‰‡ URL

class Base64Source(ImageSource):
    """Base64 å›¾ç‰‡æº"""
    type: str        # "base64"
    media_type: str  # åª’ä½“ç±»å‹ï¼ˆå¦‚ "image/png"ï¼‰
    data: str        # Base64 ç¼–ç æ•°æ®

class ImageBlock(TypedDict):
    """å›¾ç‰‡å†…å®¹å—"""
    type: str          # "image"
    source: ImageSource  # å›¾ç‰‡æ¥æº

# ä½¿ç”¨ç¤ºä¾‹ - URL å›¾ç‰‡
image_url = ImageBlock(
    type="image",
    source=URLSource(
        type="url",
        url="https://example.com/image.jpg"
    )
)

# ä½¿ç”¨ç¤ºä¾‹ - Base64 å›¾ç‰‡
with open("image.png", "rb") as f:
    image_data = base64.b64encode(f.read()).decode()

image_base64 = ImageBlock(
    type="image",
    source=Base64Source(
        type="base64",
        media_type="image/png",
        data=image_data
    )
)
```

#### 5.2.3 AudioBlock - éŸ³é¢‘å—

```python
class AudioBlock(TypedDict):
    """éŸ³é¢‘å†…å®¹å—"""
    type: str          # "audio"
    source: dict       # éŸ³é¢‘æ¥æºï¼ˆURL æˆ– Base64ï¼‰

# ä½¿ç”¨ç¤ºä¾‹
audio_block = AudioBlock(
    type="audio",
    source={
        "type": "base64",
        "media_type": "audio/wav",
        "data": "base64_audio_data..."
    }
)
```

#### 5.2.4 ToolUseBlock - å·¥å…·è°ƒç”¨å—

```python
class ToolUseBlock(TypedDict):
    """å·¥å…·è°ƒç”¨å—

    è¡¨ç¤º LLM å†³å®šè°ƒç”¨æŸä¸ªå·¥å…·
    """
    type: str       # "tool_use"
    id: str         # å·¥å…·è°ƒç”¨ ID
    name: str       # å·¥å…·åç§°
    input: dict     # å·¥å…·å‚æ•°ï¼ˆJSON å¯¹è±¡ï¼‰

# ä½¿ç”¨ç¤ºä¾‹
tool_use = ToolUseBlock(
    type="tool_use",
    id="call_123",
    name="execute_python_code",
    input={
        "code": "print(2 + 2)"
    }
)
```

#### 5.2.5 ToolResultBlock - å·¥å…·ç»“æœå—

```python
class ToolResultBlock(TypedDict):
    """å·¥å…·ç»“æœå—

    è¡¨ç¤ºå·¥å…·æ‰§è¡Œçš„ç»“æœ
    """
    type: str              # "tool_result"
    id: str                # å·¥å…·è°ƒç”¨ IDï¼ˆå¯¹åº” ToolUseBlock çš„ idï¼‰
    output: str | list[ContentBlock]  # å·¥å…·è¾“å‡º

# ä½¿ç”¨ç¤ºä¾‹
tool_result = ToolResultBlock(
    type="tool_result",
    id="call_123",
    output="4\n"  # æˆ–è€…æ˜¯æ›´å¤æ‚çš„å†…å®¹å—åˆ—è¡¨
)
```

#### 5.2.6 ThinkingBlock - æ€è€ƒå—

```python
class ThinkingBlock(TypedDict):
    """æ€è€ƒå—

    æŸäº›æ¨¡å‹ï¼ˆå¦‚ Claudeï¼‰æ”¯æŒå±•ç¤ºå…¶æ€è€ƒè¿‡ç¨‹
    """
    type: str       # "thinking"
    thinking: str   # æ€è€ƒå†…å®¹

# ä½¿ç”¨ç¤ºä¾‹
thinking = ThinkingBlock(
    type="thinking",
    thinking="Let me break this down step by step..."
)
```

### 5.3 å¤šæ¨¡æ€æ”¯æŒ

#### 5.3.1 æ„é€ å¤šæ¨¡æ€æ¶ˆæ¯

```python
# ç¤ºä¾‹ï¼šåŒ…å«æ–‡æœ¬ã€å›¾ç‰‡å’ŒéŸ³é¢‘çš„æ¶ˆæ¯
multimodal_msg = Msg(
    name="user",
    content=[
        TextBlock(
            type="text",
            text="è¯·åˆ†æè¿™å¼ å›¾ç‰‡å’Œè¿™æ®µéŸ³é¢‘"
        ),
        ImageBlock(
            type="image",
            source=URLSource(
                type="url",
                url="https://example.com/chart.png"
            )
        ),
        AudioBlock(
            type="audio",
            source={
                "type": "base64",
                "media_type": "audio/wav",
                "data": audio_base64_data
            }
        )
    ],
    role="user"
)
```

#### 5.3.2 å¤„ç†å¤šæ¨¡æ€å†…å®¹

```python
def process_multimodal_message(msg: Msg):
    """å¤„ç†å¤šæ¨¡æ€æ¶ˆæ¯"""

    # æå–æ–‡æœ¬
    text = msg.get_text_content()
    print(f"æ–‡æœ¬: {text}")

    # æå–å›¾ç‰‡
    images = msg.get_content_blocks("image")
    for img in images:
        if img["source"]["type"] == "url":
            print(f"å›¾ç‰‡ URL: {img['source']['url']}")
        elif img["source"]["type"] == "base64":
            print(f"å›¾ç‰‡ç±»å‹: {img['source']['media_type']}")
            # å¤„ç† Base64 æ•°æ®

    # æå–éŸ³é¢‘
    audios = msg.get_content_blocks("audio")
    for audio in audios:
        print(f"éŸ³é¢‘: {audio['source']}")
```

### 5.4 æ¶ˆæ¯åºåˆ—åŒ–

#### 5.4.1 JSON åºåˆ—åŒ–

```python
import json

# åºåˆ—åŒ–æ¶ˆæ¯
msg = Msg(
    name="agent1",
    content="Hello",
    role="assistant"
)

msg_dict = msg.to_dict()
msg_json = json.dumps(msg_dict, ensure_ascii=False, indent=2)

print(msg_json)
# {
#   "id": "abc123",
#   "name": "agent1",
#   "content": [{"type": "text", "text": "Hello"}],
#   "role": "assistant",
#   "metadata": null,
#   "timestamp": "2025-10-07T10:30:00",
#   "invocation_id": null
# }

# ååºåˆ—åŒ–
loaded_dict = json.loads(msg_json)
loaded_msg = Msg.from_dict(loaded_dict)

assert loaded_msg.name == msg.name
assert loaded_msg.get_text_content() == msg.get_text_content()
```

#### 5.4.2 ä¿å­˜å’ŒåŠ è½½æ¶ˆæ¯å†å²

```python
class MessageHistory:
    """æ¶ˆæ¯å†å²ç®¡ç†"""

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.messages: list[Msg] = []

    def add(self, msg: Msg):
        """æ·»åŠ æ¶ˆæ¯"""
        self.messages.append(msg)

    def save(self):
        """ä¿å­˜åˆ°æ–‡ä»¶"""
        with open(self.file_path, "w", encoding="utf-8") as f:
            json.dump(
                [msg.to_dict() for msg in self.messages],
                f,
                ensure_ascii=False,
                indent=2
            )

    def load(self):
        """ä»æ–‡ä»¶åŠ è½½"""
        with open(self.file_path, "r", encoding="utf-8") as f:
            data = json.load(f)
            self.messages = [Msg.from_dict(d) for d in data]

    def get_all(self) -> list[Msg]:
        """è·å–æ‰€æœ‰æ¶ˆæ¯"""
        return self.messages

# ä½¿ç”¨ç¤ºä¾‹
history = MessageHistory("conversation.json")

history.add(Msg("user", "Hello", "user"))
history.add(Msg("assistant", "Hi there!", "assistant"))
history.add(Msg("user", "How are you?", "user"))

history.save()

# ç¨ååŠ è½½
new_history = MessageHistory("conversation.json")
new_history.load()

for msg in new_history.get_all():
    print(f"{msg.name}: {msg.get_text_content()}")
```

---

## ç¬¬å…­ç« : Tool å·¥å…·ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/tool/`

### 6.1 Toolkit ç®¡ç†å™¨è®¾è®¡

Toolkit æ˜¯å·¥å…·ç®¡ç†çš„æ ¸å¿ƒï¼Œè´Ÿè´£æ³¨å†Œã€ç»„ç»‡å’Œè°ƒç”¨æ‰€æœ‰å·¥å…·å‡½æ•°ã€‚

**æ ¸å¿ƒèŒè´£**:
- æ³¨å†Œå·¥å…·å‡½æ•°ï¼ˆPython å‡½æ•°ã€MCP å·¥å…·ï¼‰
- ç”Ÿæˆ JSON Schema ä¾› LLM ä½¿ç”¨
- ç®¡ç†å·¥å…·åˆ†ç»„å’Œæ¿€æ´»çŠ¶æ€
- æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆæ”¯æŒåŒæ­¥/å¼‚æ­¥/æµå¼ï¼‰

**å®Œæ•´å®ç°è¯¦è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 3.7 èŠ‚**

### 6.2 å·¥å…·æ³¨å†Œä¸ JSON Schema

å·¥å…·é€šè¿‡è£…é¥°å™¨æˆ–ç›´æ¥æ³¨å†Œæ–¹å¼æ·»åŠ åˆ° Toolkitï¼Œç³»ç»Ÿè‡ªåŠ¨ä»å‡½æ•°ç­¾åå’Œæ–‡æ¡£å­—ç¬¦ä¸²ç”Ÿæˆ JSON Schemaã€‚

**ç¤ºä¾‹**:
```python
def my_tool(param1: str, param2: int = 10) -> ToolResponse:
    """å·¥å…·æè¿°

    Args:
        param1: å‚æ•°1æè¿°
        param2: å‚æ•°2æè¿°
    """
    return ToolResponse(...)

toolkit.register_tool_function(my_tool)
# è‡ªåŠ¨ç”Ÿæˆ JSON Schema ä¾› LLM è°ƒç”¨
```

### 6.3 å·¥å…·ç»„ç®¡ç†

å·¥å…·å¯ä»¥ç»„ç»‡ä¸ºé€»è¾‘ç»„ï¼ŒåŠ¨æ€å¯ç”¨/ç¦ç”¨ï¼š

```python
toolkit.create_tool_group("web", "Web tools", active=False)
toolkit.register_tool_function(fetch_url, group_name="web")

# æ ¹æ®éœ€è¦æ¿€æ´»
toolkit.update_tool_groups(["web"], active=True)
```

### 6.4 MCP å·¥å…·é›†æˆ

æ”¯æŒé€šè¿‡ MCP åè®®é›†æˆå¤–éƒ¨å·¥å…·æœåŠ¡å™¨ï¼š

```python
mcp_client = HttpStatelessClient(url="...")
await toolkit.register_mcp_client(mcp_client)
# MCP å·¥å…·è‡ªåŠ¨æ³¨å†Œä¸ºæ™®é€šå·¥å…·å‡½æ•°
```

### 6.5 å†…ç½®å·¥å…·

AgentScope æä¾›äº†ä»£ç æ‰§è¡Œã€æ–‡ä»¶æ“ä½œã€å¤šæ¨¡æ€ç”Ÿæˆç­‰å†…ç½®å·¥å…·ã€‚è¯¦ç»†å®ç°å‚è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ã€‚

---

## ç¬¬ä¸ƒç« : Memory è®°å¿†ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/memory/`

### 7.1 çŸ­æœŸè®°å¿†ï¼ˆInMemoryMemoryï¼‰

å­˜å‚¨å½“å‰å¯¹è¯çš„æ¶ˆæ¯å†å²ï¼ŒAgent é€šè¿‡çŸ­æœŸè®°å¿†ç»´æŒä¸Šä¸‹æ–‡ã€‚

**æ ¸å¿ƒæ–¹æ³•**:
```python
memory = InMemoryMemory()
await memory.add(msg)              # æ·»åŠ æ¶ˆæ¯
messages = await memory.get_memory()  # è·å–æ‰€æœ‰æ¶ˆæ¯
await memory.clear()               # æ¸…ç©ºè®°å¿†
```

### 7.2 é•¿æœŸè®°å¿†ï¼ˆMem0LongTermMemoryï¼‰

é€šè¿‡ Mem0 å¹³å°å®ç°æŒä¹…åŒ–è®°å¿†ï¼Œæ”¯æŒè·¨ä¼šè¯çš„çŸ¥è¯†ä¿å­˜å’Œæ£€ç´¢ã€‚

**ä¸‰ç§ç®¡ç†æ¨¡å¼**:
1. **agent_control**: Agent é€šè¿‡å·¥å…·å‡½æ•°ä¸»åŠ¨æ§åˆ¶
2. **static_control**: æ¯æ¬¡å¯¹è¯è‡ªåŠ¨æ£€ç´¢å’Œè®°å½•
3. **both**: è‡ªåŠ¨ç®¡ç† + Agent å¯ä¸»åŠ¨è°ƒç”¨

### 7.3 è®°å¿†ç®¡ç†ç­–ç•¥

**ç¤ºä¾‹**:
```python
agent = ReActAgent(
    long_term_memory=Mem0LongTermMemory(...),
    long_term_memory_mode="both",  # è‡ªåŠ¨ + ä¸»åŠ¨
    ...
)
# Agent æ¯æ¬¡ reply() å¼€å§‹æ—¶è‡ªåŠ¨æ£€ç´¢ç›¸å…³è®°å¿†
# Agent ä¹Ÿå¯ä»¥ä¸»åŠ¨è°ƒç”¨ retrieve_from_memory å·¥å…·
```

---

## ç¬¬å…«ç« : Formatter æ ¼å¼åŒ–ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/formatter/`

### 8.1 FormatterBase åŸºç±»

Formatter è´Ÿè´£å°† AgentScope çš„ Msg å¯¹è±¡è½¬æ¢ä¸ºä¸åŒ LLM API æ‰€éœ€çš„æ ¼å¼ã€‚

**æ ¸å¿ƒæ–¹æ³•**:
```python
async def format(
    self,
    msgs: list[Msg],
    tools: list[dict] | None = None
) -> list[dict]:
    """æ ¼å¼åŒ–æ¶ˆæ¯ä¸º API æ ¼å¼"""
```

### 8.2 å„å‚å•† Formatter

ä¸åŒ LLM æä¾›å•†æœ‰ä¸åŒçš„æ¶ˆæ¯æ ¼å¼ï¼š

**DashScopeChatFormatter**: é˜¿é‡Œäº‘é€šä¹‰åƒé—®æ ¼å¼
**OpenAIChatFormatter**: OpenAI GPT æ ¼å¼
**AnthropicChatFormatter**: Anthropic Claude æ ¼å¼ï¼ˆsystem æ¶ˆæ¯å•ç‹¬ä¼ é€’ï¼‰
**GeminiChatFormatter**: Google Gemini æ ¼å¼

### 8.3 æˆªæ–­ç­–ç•¥

å½“æ¶ˆæ¯å†å²è¿‡é•¿æ—¶ï¼ŒFormatter å¯ä»¥ä½¿ç”¨æˆªæ–­ç­–ç•¥ï¼š

```python
formatter = DashScopeChatFormatter(
    max_length=4000,  # æœ€å¤§ token æ•°
    truncation_mode="keep_recent"  # ä¿ç•™æœ€è¿‘çš„æ¶ˆæ¯
)
```

---

## ç¬¬ä¹ç« : Pipeline å·¥ä½œæµç¼–æ’

**æ–‡ä»¶ä½ç½®**: `src/agentscope/pipeline/`

### 9.1 MsgHub æ¶ˆæ¯ä¸­å¿ƒ

MsgHub å®ç°å‘å¸ƒ-è®¢é˜…æ¨¡å¼ï¼ŒAgent ä¹‹é—´è‡ªåŠ¨å¹¿æ’­æ¶ˆæ¯ï¼š

```python
async with MsgHub([agent1, agent2, agent3], announcement=topic_msg) as hub:
    await agent1(msg)  # agent1 çš„å›å¤è‡ªåŠ¨å¹¿æ’­ç»™ agent2 å’Œ agent3
    await agent2()      # agent2 å·²ç»"å¬åˆ°"äº† agent1 çš„å›å¤
```

### 9.2 Pipeline æ¨¡å¼

**é¡ºåºæ‰§è¡Œ**:
```python
result = await sequential_pipeline([agent1, agent2, agent3], initial_msg)
# agent1 â†’ agent2 â†’ agent3
```

**å¹¶è¡Œæ‰§è¡Œ**:
```python
results = await fanout_pipeline([agent1, agent2, agent3], query_msg)
# agent1 â•‘ agent2 â•‘ agent3 (å¹¶è¡Œ)
```

### 9.3 å¤æ‚å·¥ä½œæµè®¾è®¡

ç»„åˆä½¿ç”¨ MsgHub å’Œ Pipeline å¯ä»¥æ„å»ºå¤æ‚çš„å¤š Agent åä½œæµç¨‹ã€‚è¯¦è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 3.7 èŠ‚ã€‚

---

## ç¬¬åç« : Plan è§„åˆ’ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/plan/`

### 10.1 PlanNotebook è®¾è®¡

PlanNotebook å¸®åŠ© Agent ç®¡ç†å¤æ‚ä»»åŠ¡çš„è§„åˆ’å’Œæ‰§è¡Œï¼š

**æ ¸å¿ƒåŠŸèƒ½**:
- åˆ›å»ºå¤šå±‚çº§ä»»åŠ¡è®¡åˆ’ï¼ˆPlan åŒ…å«å¤šä¸ª SubTaskï¼‰
- è¿½è¸ªä»»åŠ¡æ‰§è¡ŒçŠ¶æ€ï¼ˆtodo, in_progress, done, abandonedï¼‰
- ä¸º Agent ç”Ÿæˆå½“å‰ä»»åŠ¡æç¤º
- æä¾›è§„åˆ’ç›¸å…³çš„å·¥å…·å‡½æ•°

### 10.2 ä»»åŠ¡åˆ†è§£æœºåˆ¶

Agent å¯ä»¥è°ƒç”¨å·¥å…·å‡½æ•°åˆ›å»ºè®¡åˆ’ï¼š

```python
# Agent è°ƒç”¨ create_plan å·¥å…·
{
    "name": "å¼€å‘ Web çˆ¬è™«",
    "description": "...",
    "expected_outcome": "...",
    "subtasks": [
        {"name": "ç ”ç©¶åº“", "description": "...", "expected_outcome": "..."},
        {"name": "è®¾è®¡æ¶æ„", "description": "...", "expected_outcome": "..."},
        {"name": "å®ç°ä»£ç ", "description": "...", "expected_outcome": "..."},
    ]
}
```

### 10.3 è®¡åˆ’æ‰§è¡Œè¿½è¸ª

PlanNotebook åœ¨æ¯æ¬¡ Agent æ¨ç†æ—¶æä¾›å½“å‰ä»»åŠ¡æç¤ºï¼š

```python
plan_notebook = PlanNotebook()
agent = ReActAgent(plan_notebook=plan_notebook, ...)

# Agent ä¼šè‡ªåŠ¨è·å¾—ç±»ä¼¼è¿™æ ·çš„æç¤ºï¼š
# Current Plan: å¼€å‘ Web çˆ¬è™«
# Current Subtask (2/3): è®¾è®¡æ¶æ„
# - Description: ...
# - Expected Outcome: ...
# Please work on this subtask. When finished, call finish_subtask().
```

è¯¦ç»†å®ç°å‚è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 3.8 èŠ‚ã€‚

---

## ç¬¬åä¸€ç« : RAG æ£€ç´¢å¢å¼º

**æ–‡ä»¶ä½ç½®**: `src/agentscope/rag/`

### 11.1 KnowledgeBase è®¾è®¡

KnowledgeBase æä¾›åŸºäºå‘é‡æ£€ç´¢çš„çŸ¥è¯†å¢å¼ºèƒ½åŠ›ï¼š

**æ ¸å¿ƒç»„ä»¶**:
- **Document**: æ–‡æ¡£æ¨¡å‹ï¼ˆå†…å®¹ + å‘é‡ + å…ƒæ•°æ®ï¼‰
- **EmbeddingModel**: æ–‡æœ¬å‘é‡åŒ–æ¨¡å‹
- **VDBStore**: å‘é‡æ•°æ®åº“å­˜å‚¨ï¼ˆå¦‚ Qdrantï¼‰
- **Reader**: æ–‡æ¡£è¯»å–å™¨ï¼ˆText, PDF, Imageï¼‰

### 11.2 æ–‡æ¡£å¤„ç†

æ–‡æ¡£ç»è¿‡è¯»å–ã€åˆ†å—ã€å‘é‡åŒ–åå­˜å…¥çŸ¥è¯†åº“ï¼š

```python
kb = SimpleKnowledgeBase(
    embedding_model=DashScopeTextEmbedding(...),
    store=QdrantStore(...)
)

# æ·»åŠ æ–‡æ¡£
await kb.add_files(["manual.pdf", "faq.txt"])
```

### 11.3 å‘é‡æ£€ç´¢

Agent æŸ¥è¯¢æ—¶è‡ªåŠ¨æ£€ç´¢ç›¸å…³æ–‡æ¡£ï¼š

```python
agent = ReActAgent(
    knowledge=[kb1, kb2],
    enable_rewrite_query=True,  # æŸ¥è¯¢é‡å†™ä¼˜åŒ–
    ...
)

# Agent æ¯æ¬¡ reply() å¼€å§‹æ—¶ï¼š
# 1. ä»çŸ¥è¯†åº“æ£€ç´¢ç›¸å…³æ–‡æ¡£
# 2. å°†æ–‡æ¡£æ·»åŠ åˆ°è®°å¿†
# 3. LLM åŸºäºæ–‡æ¡£ç”Ÿæˆå›å¤
```

è¯¦ç»†å®ç°å‚è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 3.9 èŠ‚ã€‚

---

## ç¬¬åäºŒç« : MCP åè®®é›†æˆ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/mcp/`

### 12.1 MCP å®¢æˆ·ç«¯æ¶æ„

MCP (Model Context Protocol) å…è®¸ Agent è¿æ¥å¤–éƒ¨å·¥å…·æœåŠ¡å™¨ã€‚

**æ”¯æŒçš„ä¼ è¾“æ–¹å¼**:
- **HTTP Stateless**: æ— çŠ¶æ€ HTTP è¯·æ±‚
- **HTTP Stateful**: æœ‰çŠ¶æ€ HTTP ä¼šè¯
- **StdIO**: é€šè¿‡æ ‡å‡†è¾“å…¥/è¾“å‡ºä¸æœ¬åœ°è¿›ç¨‹é€šä¿¡

### 12.2 HTTP å®¢æˆ·ç«¯

```python
from agentscope.mcp import HttpStatelessClient

client = HttpStatelessClient(url="https://mcp.example.com")
await toolkit.register_mcp_client(client)
# MCP å·¥å…·è‡ªåŠ¨æ³¨å†Œåˆ° toolkit
```

### 12.3 StdIO å®¢æˆ·ç«¯

ç”¨äºå¯åŠ¨æœ¬åœ° MCP æœåŠ¡å™¨è¿›ç¨‹ï¼š

```python
from agentscope.mcp import StdIOStatefulClient

async with StdIOStatefulClient(
    command="python",
    args=["mcp_server.py"]
) as client:
    result = await client.call_tool("analyze", {"text": "..."})
```

è¯¦ç»†å®ç°å‚è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 3.10 èŠ‚ã€‚

---

## ç¬¬åä¸‰ç« : è¾…åŠ©æ¨¡å—

### 13.1 Embedding åµŒå…¥æ¨¡å‹

**æ–‡ä»¶ä½ç½®**: `src/agentscope/embedding/`

æ”¯æŒæ–‡æœ¬å‘é‡åŒ–ï¼Œç”¨äº RAG ç­‰åœºæ™¯ï¼š

```python
embedding_model = DashScopeTextEmbedding(model_name="text-embedding-v1")
embeddings = await embedding_model(["text1", "text2"])
```

**æ”¯æŒç¼“å­˜**å‡å°‘ API è°ƒç”¨ï¼š
```python
from agentscope.embedding import FileEmbeddingCache

cache = FileEmbeddingCache(cache_dir="./cache")
embedding_model = DashScopeTextEmbedding(cache=cache)
```

### 13.2 Token è®¡æ•°

**æ–‡ä»¶ä½ç½®**: `src/agentscope/token/`

ç”¨äºä¼°ç®— token ä½¿ç”¨å’Œæˆæœ¬ï¼š

```python
from agentscope.token import OpenAITokenCounter

counter = OpenAITokenCounter(model_name="gpt-4")
token_count = counter.count(messages)
cost = counter.estimate_cost(token_count)
```

### 13.3 Session ä¼šè¯ç®¡ç†

**æ–‡ä»¶ä½ç½®**: `src/agentscope/session/`

ä¿å­˜å’Œæ¢å¤ Agent çŠ¶æ€ï¼š

```python
from agentscope.session import JsonSession

session = JsonSession(session_dir="./sessions", session_id="user_001")
session.save_agent(agent)

# ç¨ååŠ è½½
loaded_agent = session.load_agent("agent_name")
```

### 13.4 Tracing è¿½è¸ªç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/agentscope/tracing/`

åŸºäº OpenTelemetry çš„åˆ†å¸ƒå¼è¿½è¸ªï¼š

```python
from agentscope.tracing import setup_tracing

setup_tracing(
    endpoint="http://localhost:4317",  # Jaeger/Phoenix
    service_name="my_agent_app"
)
# æ‰€æœ‰ Agentã€Modelã€Tool è°ƒç”¨è‡ªåŠ¨è¿½è¸ª
```

---

## ç¬¬åå››ç« : æ‰§è¡Œæµç¨‹æ·±åº¦å‰–æ

### 14.1 ReActAgent å®Œæ•´æ‰§è¡Œæµ

å®Œæ•´çš„æ‰§è¡Œæµç¨‹å·²åœ¨ç¬¬ä¸‰ç« è¯¦ç»†æè¿°ã€‚æ ¸å¿ƒæµç¨‹ï¼š

```
1. ç”¨æˆ·è¾“å…¥ â†’ UserAgent
2. ReActAgent.__call__()
   â”œâ”€ pre_reply é’©å­
   â”œâ”€ reply()
   â”‚  â”œâ”€ memory.add(msg)
   â”‚  â”œâ”€ long_term_memory.retrieve() [å¯é€‰]
   â”‚  â”œâ”€ knowledge.retrieve() [å¯é€‰]
   â”‚  â”œâ”€ plan_notebook.get_hint() [å¯é€‰]
   â”‚  â””â”€ ReAct å¾ªç¯ï¼ˆæœ€å¤š max_iters æ¬¡ï¼‰
   â”‚     â”œâ”€ _reasoning()
   â”‚     â”‚  â”œâ”€ formatter.format()
   â”‚     â”‚  â”œâ”€ model()
   â”‚     â”‚  â””â”€ æå– tool_calls
   â”‚     â”œâ”€ _acting(tool_calls) [å¦‚æœæœ‰]
   â”‚     â”‚  â””â”€ toolkit.call_tool_function()
   â”‚     â””â”€ ç»§ç»­å¾ªç¯æˆ–ç»“æŸ
   â”œâ”€ post_reply é’©å­
   â”œâ”€ _broadcast_to_subscribers()
   â””â”€ print()
3. è¿”å›å“åº”
```

### 14.2 å¤š Agent åä½œæµç¨‹

é€šè¿‡ MsgHub å®ç°è‡ªåŠ¨æ¶ˆæ¯å¹¿æ’­ï¼š

```
MsgHub([agent1, agent2, agent3])
â”œâ”€ è®¾ç½®è®¢é˜…å…³ç³»
â”‚  agent1 è®¢é˜… [agent2, agent3]
â”‚  agent2 è®¢é˜… [agent1, agent3]
â”‚  agent3 è®¢é˜… [agent1, agent2]
â””â”€ æ‰§è¡Œæµç¨‹
   agent1(msg) â†’ response1
   â””â”€ è‡ªåŠ¨å¹¿æ’­ â†’ agent2.observe(response1)
                 agent3.observe(response1)
```

### 14.3 å·¥å…·è°ƒç”¨æµç¨‹

è¯¦è§ç¬¬å…­ç«  6.6 èŠ‚ã€‚æ ¸å¿ƒæ­¥éª¤ï¼š

1. LLM è¿”å› ToolUseBlock
2. Agent æå–å·¥å…·è°ƒç”¨
3. Toolkit æŸ¥æ‰¾å¹¶æ‰§è¡Œå·¥å…·
4. ç»“æœåŒ…è£…ä¸º ToolResultBlock
5. æ·»åŠ åˆ°è®°å¿†ï¼Œç»§ç»­ä¸‹ä¸€è½®æ¨ç†

---

## ç¬¬åäº”ç« : æ‰©å±•å¼€å‘æŒ‡å—

### 15.1 è‡ªå®šä¹‰ Agent

**ç»§æ‰¿ AgentBase**:
```python
class MyAgent(AgentBase):
    async def reply(self, msg: Msg) -> Msg:
        # è‡ªå®šä¹‰é€»è¾‘
        return Msg(self.name, "response", "assistant")
```

**ç»§æ‰¿ ReActAgent**:
```python
class MyEnhancedAgent(ReActAgent):
    async def _reasoning(self, *args, **kwargs):
        # è‡ªå®šä¹‰æ¨ç†è¿‡ç¨‹
        return await super()._reasoning(*args, **kwargs)
```

### 15.2 è‡ªå®šä¹‰å·¥å…·å‡½æ•°

```python
def my_tool(param1: str, param2: int) -> ToolResponse:
    """å·¥å…·æè¿°

    Args:
        param1: å‚æ•°æè¿°
        param2: å‚æ•°æè¿°
    """
    result = process(param1, param2)
    return ToolResponse(
        content=[TextBlock(type="text", text=result)]
    )

toolkit.register_tool_function(my_tool)
```

**å¼‚æ­¥å·¥å…·**:
```python
async def async_tool(url: str) -> ToolResponse:
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            text = await response.text()
    return ToolResponse(content=[TextBlock(type="text", text=text)])
```

**æµå¼å·¥å…·**:
```python
async def streaming_tool(data: str) -> AsyncGenerator[ToolResponse, None]:
    for chunk in process_stream(data):
        yield ToolResponse(
            content=[TextBlock(type="text", text=chunk)],
            stream=True,
            is_last=False
        )
    yield ToolResponse(
        content=[TextBlock(type="text", text="Complete")],
        stream=True,
        is_last=True
    )
```

### 15.3 è‡ªå®šä¹‰ç»„ä»¶

**è‡ªå®šä¹‰ Memory**:
```python
class MyMemory(MemoryBase):
    async def add(self, memories): ...
    async def get_memory(self): ...
    async def clear(self): ...
```

**è‡ªå®šä¹‰ Formatter**:
```python
class MyFormatter(FormatterBase):
    async def format(self, msgs, tools=None):
        # è½¬æ¢ä¸ºè‡ªå®šä¹‰ API æ ¼å¼
        return formatted_messages
```

**è‡ªå®šä¹‰ KnowledgeBase**:
```python
class MyKnowledgeBase(KnowledgeBase):
    async def add_documents(self, documents): ...
    async def retrieve(self, query, limit, score_threshold): ...
```

è¯¦ç»†ç¤ºä¾‹å‚è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 7 ç« ã€‚

---

## ç¬¬åå…­ç« : æœ€ä½³å®è·µä¸ä¼˜åŒ–

### 16.1 æ€§èƒ½ä¼˜åŒ–

**å¹¶è¡Œæ‰§è¡Œ**:
```python
# å¹¶è¡Œ Agent è°ƒç”¨
results = await asyncio.gather(
    agent1(msg), agent2(msg), agent3(msg)
)

# å¹¶è¡Œå·¥å…·è°ƒç”¨ï¼ˆReActAgent è‡ªåŠ¨æ”¯æŒï¼‰
agent = ReActAgent(parallel_tool_calls=True, ...)
```

**ä½¿ç”¨ç¼“å­˜**:
```python
# Embedding ç¼“å­˜
embedding_model = DashScopeTextEmbedding(cache=FileEmbeddingCache(...))

# å‡å°‘ä¸å¿…è¦çš„ API è°ƒç”¨
```

**æµå¼è¾“å‡º**:
```python
# æå‡ç”¨æˆ·ä½“éªŒ
model = DashScopeChatModel(stream=True)
agent = ReActAgent(model=model, ...)
```

### 16.2 é”™è¯¯å¤„ç†

**æ•è·ç‰¹å®šå¼‚å¸¸**:
```python
from agentscope.exception import ToolNotFoundError

try:
    result = await agent(msg)
except ToolNotFoundError as e:
    logger.error(f"Tool '{e.tool_name}' not found")
    # å¤„ç†
```

**ä¼˜é›…é™çº§**:
```python
async def robust_call(agent, msg, max_retries=3):
    for attempt in range(max_retries):
        try:
            return await agent(msg)
        except Exception as e:
            if attempt == max_retries - 1:
                return Msg("system", f"Error: {e}", "system")
            await asyncio.sleep(2 ** attempt)
```

### 16.3 æµ‹è¯•ç­–ç•¥

**Mock Model**:
```python
class MockModel(ChatModelBase):
    def __init__(self, responses):
        self.responses = responses
        self.call_count = 0

    async def __call__(self, messages, **kwargs):
        response = self.responses[self.call_count]
        self.call_count += 1
        return ChatResponse(
            content=[TextBlock(type="text", text=response)],
            ...
        )
```

**çŠ¶æ€åºåˆ—åŒ–æµ‹è¯•**:
```python
# æµ‹è¯• Agent çŠ¶æ€ä¿å­˜å’Œæ¢å¤
state = agent.state_dict()
new_agent = ReActAgent(...)
new_agent.load_state_dict(state)
assert agent.memory.content == new_agent.memory.content
```

**å·¥å…·æµ‹è¯•**:
```python
# å•ç‹¬æµ‹è¯•å·¥å…·å‡½æ•°
result = await my_tool(param1="test", param2=10)
assert isinstance(result, ToolResponse)
assert "expected" in result.content[0]["text"]
```

æ›´å¤šæœ€ä½³å®è·µå‚è§ç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ç¬¬ 8 ç« ã€‚

---

## é™„å½•

### A.1 å¸¸ç”¨å¯¼å…¥

```python
# æ ¸å¿ƒç»„ä»¶
from agentscope.agent import ReActAgent, UserAgent
from agentscope.message import Msg
from agentscope.model import DashScopeChatModel, OpenAIChatModel
from agentscope.formatter import DashScopeChatFormatter
from agentscope.memory import InMemoryMemory
from agentscope.tool import Toolkit, ToolResponse
from agentscope.pipeline import MsgHub, sequential_pipeline, fanout_pipeline

# é«˜çº§åŠŸèƒ½
from agentscope.plan import PlanNotebook
from agentscope.rag import SimpleKnowledgeBase
from agentscope.mcp import HttpStatelessClient
from agentscope.embedding import DashScopeTextEmbedding
```

### A.2 å¿«é€Ÿå¼€å§‹æ¨¡æ¿

```python
import agentscope
from agentscope.agent import ReActAgent
from agentscope.message import Msg
from agentscope.model import DashScopeChatModel
from agentscope.formatter import DashScopeChatFormatter
from agentscope.memory import InMemoryMemory
from agentscope.tool import Toolkit

# åˆå§‹åŒ–
agentscope.init(project="my_project", logging_level="INFO")

# åˆ›å»º Agent
agent = ReActAgent(
    name="assistant",
    sys_prompt="You are a helpful assistant",
    model=DashScopeChatModel(
        model_name="qwen-max",
        api_key="your_api_key"
    ),
    memory=InMemoryMemory(),
    formatter=DashScopeChatFormatter(),
    toolkit=Toolkit()
)

# ä½¿ç”¨ Agent
msg = Msg("user", "Hello!", "user")
response = await agent(msg)
print(response.get_text_content())
```

### A.3 å‚è€ƒèµ„æº

**å®˜æ–¹èµ„æº**:
- GitHub: https://github.com/agentscope-ai/agentscope
- æ–‡æ¡£: https://doc.agentscope.io/
- è®ºæ–‡: https://arxiv.org/abs/2508.16279

**ç¤¾åŒº**:
- Discord: https://discord.gg/eYMpfnkG8h

---

## æ–‡æ¡£å®Œæˆ

æœ¬æ–‡æ¡£å…¨é¢åˆ†æäº† AgentScope é¡¹ç›®çš„ï¼š
- âœ… é¡¹ç›®æ¦‚è§ˆä¸æ ¸å¿ƒç†å¿µï¼ˆç¬¬ä¸€ç« ï¼‰
- âœ… æ ¸å¿ƒæ¶æ„è®¾è®¡ï¼ˆç¬¬äºŒç« ï¼‰
- âœ… Agent æ¨¡å—æ·±åº¦è§£æï¼ˆç¬¬ä¸‰ç« ï¼‰
- âœ… Model æ¨¡å—è¯¦ç»†åˆ†æï¼ˆç¬¬å››ç« ï¼‰
- âœ… Message ä¸é€šä¿¡æœºåˆ¶ï¼ˆç¬¬äº”ç« ï¼‰
- âœ… Tool å·¥å…·ç³»ç»Ÿï¼ˆç¬¬å…­ç« ï¼‰
- âœ… Memory è®°å¿†ç³»ç»Ÿï¼ˆç¬¬ä¸ƒç« ï¼‰
- âœ… Formatter æ ¼å¼åŒ–ç³»ç»Ÿï¼ˆç¬¬å…«ç« ï¼‰
- âœ… Pipeline å·¥ä½œæµç¼–æ’ï¼ˆç¬¬ä¹ç« ï¼‰
- âœ… Plan è§„åˆ’ç³»ç»Ÿï¼ˆç¬¬åç« ï¼‰
- âœ… RAG æ£€ç´¢å¢å¼ºï¼ˆç¬¬åä¸€ç« ï¼‰
- âœ… MCP åè®®é›†æˆï¼ˆç¬¬åäºŒç« ï¼‰
- âœ… è¾…åŠ©æ¨¡å—ï¼ˆç¬¬åä¸‰ç« ï¼‰
- âœ… æ‰§è¡Œæµç¨‹æ·±åº¦å‰–æï¼ˆç¬¬åå››ç« ï¼‰
- âœ… æ‰©å±•å¼€å‘æŒ‡å—ï¼ˆç¬¬åäº”ç« ï¼‰
- âœ… æœ€ä½³å®è·µä¸ä¼˜åŒ–ï¼ˆç¬¬åå…­ç« ï¼‰

**æ–‡æ¡£è¯´æ˜**:
- æœ¬æ–‡æ¡£æ•´åˆäº†é¡¹ç›®çš„å®Œæ•´æ¶æ„åˆ†æ
- ç¬¬ä¸€è‡³ç¬¬äº”ç« æä¾›äº†è¯¦ç»†çš„ä»£ç å®ç°å’Œè®¾è®¡ç†å¿µ
- ç¬¬å…­è‡³ç¬¬åå…­ç« æä¾›äº†æ ¸å¿ƒæ¦‚å¿µå’Œè¦ç‚¹æ€»ç»“
- æ›´è¯¦ç»†çš„å®ç°ç»†èŠ‚å’Œä»£ç ç¤ºä¾‹è¯·å‚è€ƒç¬¬äºŒéƒ¨åˆ†æ–‡æ¡£ï¼ˆ`AgentScopeé¡¹ç›®æ¶æ„åˆ†ææ–‡æ¡£-ç¬¬äºŒéƒ¨åˆ†.md`ï¼‰

**æ¨èé˜…è¯»é¡ºåº**:
1. ç¬¬ä¸€ç« ï¼šäº†è§£é¡¹ç›®èƒŒæ™¯å’Œè®¾è®¡ç†å¿µ
2. ç¬¬äºŒç« ï¼šç†è§£æ•´ä½“æ¶æ„
3. ç¬¬ä¸‰ç« ï¼šæ·±å…¥å­¦ä¹  Agent å®ç°
4. ç¬¬å››ã€äº”ç« ï¼šæŒæ¡ Model å’Œ Message æœºåˆ¶
5. ç¬¬å…­è‡³åäºŒç« ï¼šå­¦ä¹ å„æ ¸å¿ƒæ¨¡å—
6. ç¬¬åä¸‰è‡³åå…­ç« ï¼šåº”ç”¨å®è·µå’Œä¼˜åŒ–

å¸Œæœ›è¿™ä»½æ–‡æ¡£èƒ½å¸®åŠ©æ‚¨æ·±å…¥ç†è§£å’Œä½¿ç”¨ AgentScope æ¡†æ¶ï¼

---

*æ–‡æ¡£ç‰ˆæœ¬: 2.0 å®Œæ•´ç‰ˆ*
*æœ€åæ›´æ–°: 2025-10-07*
*é¡¹ç›®ç‰ˆæœ¬: AgentScope 1.0.4*

